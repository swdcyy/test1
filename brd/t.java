package brd.t;
import brd.w;
import java.lang.Object;
import java.lang.Iterable;
import java.lang.String;
import io.reactivex.internal.functions.a;
import io.reactivex.internal.operators.observable.ObservableAmb;
import ird.a;
import brd.h;
import erd.n;
import erd.o;
import io.reactivex.internal.functions.Functions;
import erd.m;
import erd.l;
import erd.k;
import erd.j;
import erd.i;
import erd.h;
import erd.c;
import io.reactivex.internal.operators.observable.ObservableCombineLatest;
import io.reactivex.internal.operators.observable.ObservableConcatMap;
import io.reactivex.internal.util.ErrorMode;
import io.reactivex.g;
import io.reactivex.internal.operators.observable.ObservableCreate;
import java.util.concurrent.Callable;
import io.reactivex.internal.operators.observable.s;
import io.reactivex.internal.operators.observable.f0;
import java.lang.Throwable;
import io.reactivex.internal.operators.observable.g0;
import io.reactivex.internal.operators.observable.j0;
import io.reactivex.internal.operators.observable.k0;
import java.util.concurrent.Future;
import io.reactivex.internal.operators.observable.l0;
import java.util.concurrent.TimeUnit;
import brd.z;
import io.reactivex.internal.operators.observable.m0;
import cxd.b;
import io.reactivex.internal.operators.observable.n0;
import erd.g;
import io.reactivex.internal.operators.observable.t0$m;
import erd.b;
import io.reactivex.internal.operators.observable.t0;
import io.reactivex.internal.operators.observable.p0;
import lrd.b;
import io.reactivex.internal.operators.observable.ObservableInterval;
import java.lang.Math;
import java.lang.IllegalArgumentException;
import io.reactivex.internal.operators.observable.ObservableIntervalRange;
import java.lang.StringBuilder;
import io.reactivex.internal.operators.observable.u0;
import io.reactivex.internal.operators.observable.ObservableFlatMap;
import io.reactivex.internal.operators.observable.b1;
import java.lang.Integer;
import io.reactivex.internal.operators.observable.ObservableRange;
import java.lang.Long;
import io.reactivex.internal.operators.observable.ObservableRangeLong;
import brd.a0;
import erd.d;
import io.reactivex.internal.operators.observable.ObservableSequenceEqualSingle;
import io.reactivex.internal.operators.observable.ObservableSwitchMap;
import io.reactivex.internal.operators.observable.ObservableTimer;
import io.reactivex.internal.operators.observable.o0;
import io.reactivex.internal.operators.observable.ObservableUsing;
import io.reactivex.internal.operators.observable.v1;
import io.reactivex.internal.operators.observable.t0$o;
import io.reactivex.internal.operators.observable.ObservableZip;
import erd.r;
import io.reactivex.internal.operators.observable.f;
import io.reactivex.internal.operators.observable.h;
import brd.u;
import io.reactivex.internal.observers.d;
import brd.y;
import io.reactivex.internal.observers.c;
import java.util.NoSuchElementException;
import java.util.Iterator;
import drd.a;
import crd.b;
import java.lang.RuntimeException;
import io.reactivex.internal.util.ExceptionHelper;
import io.reactivex.internal.operators.observable.BlockingObservableIterable;
import io.reactivex.internal.observers.e;
import io.reactivex.internal.operators.observable.b;
import io.reactivex.internal.operators.observable.c;
import io.reactivex.internal.operators.observable.d;
import brd.m;
import io.reactivex.internal.util.d;
import io.reactivex.internal.observers.LambdaObserver;
import erd.a;
import java.util.concurrent.CountDownLatch;
import io.reactivex.internal.util.c;
import java.lang.Thread;
import java.lang.IllegalStateException;
import io.reactivex.internal.operators.observable.j;
import io.reactivex.internal.util.ArrayListSupplier;
import io.reactivex.internal.operators.observable.ObservableBuffer;
import io.reactivex.internal.operators.observable.m;
import io.reactivex.internal.operators.observable.ObservableBufferBoundary;
import io.reactivex.internal.operators.observable.l;
import io.reactivex.internal.operators.observable.k;
import io.reactivex.internal.operators.observable.ObservableCache;
import java.lang.Class;
import io.reactivex.internal.functions.Functions$l;
import io.reactivex.internal.operators.observable.o;
import brd.x;
import io.reactivex.internal.fuseable.m;
import io.reactivex.internal.operators.observable.ObservableScalarXMap;
import brd.a;
import io.reactivex.internal.operators.mixed.ObservableConcatMapCompletable;
import io.reactivex.internal.operators.observable.ObservableConcatMapEager;
import io.reactivex.internal.operators.observable.i0;
import io.reactivex.internal.operators.mixed.ObservableConcatMapMaybe;
import io.reactivex.internal.operators.mixed.ObservableConcatMapSingle;
import brd.e0;
import io.reactivex.internal.operators.observable.ObservableConcatWithSingle;
import brd.e;
import io.reactivex.internal.operators.observable.ObservableConcatWithCompletable;
import brd.q;
import io.reactivex.internal.operators.observable.ObservableConcatWithMaybe;
import io.reactivex.internal.functions.Functions$r;
import io.reactivex.internal.operators.observable.q;
import io.reactivex.internal.operators.observable.ObservableDebounceTimed;
import io.reactivex.internal.operators.observable.r;
import io.reactivex.internal.operators.observable.t;
import io.reactivex.internal.operators.observable.t0$f;
import io.reactivex.internal.operators.observable.u;
import io.reactivex.internal.operators.observable.v;
import io.reactivex.internal.operators.observable.x;
import io.reactivex.internal.operators.observable.y;
import io.reactivex.internal.operators.observable.z;
import io.reactivex.internal.operators.observable.ObservableDoFinally;
import io.reactivex.internal.operators.observable.t0$i;
import io.reactivex.internal.operators.observable.t0$h;
import io.reactivex.internal.operators.observable.t0$g;
import io.reactivex.internal.functions.Functions$c0;
import io.reactivex.internal.functions.Functions$b0;
import io.reactivex.internal.functions.Functions$a0;
import io.reactivex.internal.operators.observable.a0;
import io.reactivex.internal.operators.observable.b0;
import io.reactivex.internal.functions.Functions$a;
import io.reactivex.internal.operators.observable.e0;
import java.lang.IndexOutOfBoundsException;
import io.reactivex.internal.operators.observable.d0;
import io.reactivex.internal.operators.observable.h0;
import io.reactivex.internal.operators.observable.t0$e;
import io.reactivex.internal.operators.observable.z0;
import io.reactivex.internal.operators.observable.ObservableFlatMapCompletableCompletable;
import io.reactivex.internal.operators.observable.ObservableFlatMapMaybe;
import io.reactivex.internal.operators.observable.ObservableFlatMapSingle;
import io.reactivex.internal.observers.ForEachWhileObserver;
import io.reactivex.internal.operators.observable.ObservableGroupBy;
import io.reactivex.internal.operators.observable.ObservableGroupJoin;
import io.reactivex.internal.operators.observable.q0;
import io.reactivex.internal.operators.observable.s0;
import io.reactivex.internal.operators.observable.ObservableJoin;
import io.reactivex.internal.operators.observable.w0;
import io.reactivex.internal.operators.observable.v0;
import io.reactivex.h;
import io.reactivex.internal.operators.observable.x0;
import io.reactivex.internal.operators.observable.y0;
import io.reactivex.internal.operators.observable.a1;
import io.reactivex.internal.operators.observable.ObservableMergeWithSingle;
import io.reactivex.internal.operators.observable.ObservableMergeWithCompletable;
import io.reactivex.internal.operators.observable.ObservableMergeWithMaybe;
import io.reactivex.internal.operators.observable.ObservableObserveOn;
import io.reactivex.internal.functions.Functions$m;
import io.reactivex.internal.operators.observable.c1;
import io.reactivex.internal.operators.observable.d1;
import io.reactivex.internal.operators.observable.w;
import io.reactivex.internal.operators.observable.ObservablePublishSelector;
import frd.a;
import java.util.concurrent.atomic.AtomicReference;
import io.reactivex.internal.operators.observable.ObservablePublish$b;
import io.reactivex.internal.operators.observable.ObservablePublish;
import io.reactivex.internal.operators.observable.f1;
import io.reactivex.internal.operators.observable.e1;
import io.reactivex.internal.operators.observable.g1;
import io.reactivex.internal.operators.observable.ObservableRepeat;
import erd.e;
import io.reactivex.internal.operators.observable.ObservableRepeatUntil;
import io.reactivex.internal.operators.observable.ObservableRepeatWhen;
import io.reactivex.internal.operators.observable.ObservableReplay;
import io.reactivex.internal.operators.observable.t0$b;
import io.reactivex.internal.operators.observable.t0$n;
import io.reactivex.internal.operators.observable.ObservableReplay$f;
import io.reactivex.internal.operators.observable.ObservableReplay$a;
import io.reactivex.internal.operators.observable.ObservableRetryPredicate;
import io.reactivex.internal.operators.observable.ObservableRetryBiPredicate;
import io.reactivex.internal.functions.Functions$k;
import io.reactivex.internal.operators.observable.ObservableRetryWhen;
import grd.f;
import io.reactivex.internal.operators.observable.ObservableSampleTimed;
import io.reactivex.internal.operators.observable.ObservableSampleWithObservable;
import io.reactivex.internal.operators.observable.h1;
import io.reactivex.internal.operators.observable.i1;
import io.reactivex.internal.operators.observable.j1;
import io.reactivex.internal.operators.observable.l1;
import io.reactivex.internal.operators.observable.k1;
import io.reactivex.internal.operators.observable.m1;
import io.reactivex.internal.operators.observable.ObservableSkipLast;
import io.reactivex.internal.operators.observable.ObservableSkipLastTimed;
import io.reactivex.internal.operators.observable.n1;
import io.reactivex.internal.operators.observable.o1;
import io.reactivex.internal.functions.Functions$NaturalComparator;
import java.util.Comparator;
import java.lang.NullPointerException;
import io.reactivex.internal.operators.observable.ObservableSubscribeOn;
import io.reactivex.internal.operators.observable.p1;
import io.reactivex.internal.operators.mixed.ObservableSwitchMapCompletable;
import io.reactivex.internal.operators.mixed.ObservableSwitchMapMaybe;
import io.reactivex.internal.operators.mixed.ObservableSwitchMapSingle;
import io.reactivex.internal.operators.observable.q1;
import io.reactivex.internal.operators.observable.r0;
import io.reactivex.internal.operators.observable.r1;
import io.reactivex.internal.operators.observable.ObservableTakeLast;
import io.reactivex.internal.operators.observable.ObservableTakeLastTimed;
import io.reactivex.internal.operators.observable.ObservableTakeUntil;
import io.reactivex.internal.operators.observable.s1;
import io.reactivex.internal.operators.observable.t1;
import io.reactivex.observers.TestObserver;
import io.reactivex.internal.operators.observable.ObservableThrottleFirstTimed;
import io.reactivex.internal.operators.observable.ObservableThrottleLatest;
import io.reactivex.internal.operators.observable.u1;
import io.reactivex.internal.operators.observable.ObservableTimeoutTimed;
import io.reactivex.internal.operators.observable.ObservableTimeout;
import io.reactivex.internal.functions.Functions$f0;
import io.reactivex.BackpressureStrategy;
import io.reactivex.internal.operators.flowable.k;
import brd.t$a;
import java.lang.Enum;
import io.reactivex.internal.operators.flowable.FlowableOnBackpressureBuffer;
import io.reactivex.internal.operators.flowable.FlowableOnBackpressureError;
import io.reactivex.internal.operators.flowable.FlowableOnBackpressureLatest;
import io.reactivex.internal.observers.h;
import io.reactivex.internal.operators.observable.w1;
import io.reactivex.internal.util.HashMapSupplier;
import io.reactivex.internal.functions.Functions$g0;
import io.reactivex.internal.functions.Functions$i0;
import io.reactivex.internal.operators.observable.ObservableUnsubscribeOn;
import io.reactivex.internal.operators.observable.ObservableWindow;
import io.reactivex.internal.operators.observable.y1;
import io.reactivex.internal.operators.observable.ObservableWindowBoundary;
import io.reactivex.internal.operators.observable.x1;
import io.reactivex.internal.operators.observable.ObservableWindowBoundarySupplier;
import io.reactivex.internal.operators.observable.ObservableWithLatestFrom;
import io.reactivex.internal.operators.observable.ObservableWithLatestFromMany;
import io.reactivex.internal.operators.observable.z1;

public abstract class t implements w	// class@000343
{

    public void t(){
       super();
    }
    public static t amb(Iterable p0){
       a.c(p0, "sources is null");
       return a.h(new ObservableAmb(null, p0));
    }
    public static t ambArray(w[] p0){
       a.c(p0, "sources is null");
       int len = p0.length;
       if (!len) {
          return t.empty();
       }
       if (len == 1) {
          return t.wrap(p0[0]);
       }
       return a.h(new ObservableAmb(p0, null));
    }
    public static int bufferSize(){
       return h.b();
    }
    public static t combineLatest(w p0,w p1,w p2,w p3,w p4,w p5,w p6,w p7,w p8,n p9){
       a.c(p0, "source1 is null");
       a.c(p1, "source2 is null");
       a.c(p2, "source3 is null");
       a.c(p3, "source4 is null");
       a.c(p4, "source5 is null");
       a.c(p5, "source6 is null");
       a.c(p6, "source7 is null");
       a.c(p7, "source8 is null");
       a.c(p8, "source9 is null");
       w[] owArray = new w[9];
       owArray[0] = p0;
       owArray[1] = p1;
       owArray[2] = p2;
       owArray[3] = p3;
       owArray[4] = p4;
       owArray[5] = p5;
       owArray[6] = p6;
       owArray[7] = p7;
       owArray[8] = p8;
       return t.combineLatest(Functions.q(p9), t.bufferSize(), owArray);
    }
    public static t combineLatest(w p0,w p1,w p2,w p3,w p4,w p5,w p6,w p7,m p8){
       a.c(p0, "source1 is null");
       a.c(p1, "source2 is null");
       a.c(p2, "source3 is null");
       a.c(p3, "source4 is null");
       a.c(p4, "source5 is null");
       a.c(p5, "source6 is null");
       a.c(p6, "source7 is null");
       a.c(p7, "source8 is null");
       w[] owArray = new w[]{p0,p1,p2,p3,p4,p5,p6,p7};
       return t.combineLatest(Functions.p(p8), t.bufferSize(), owArray);
    }
    public static t combineLatest(w p0,w p1,w p2,w p3,w p4,w p5,w p6,l p7){
       a.c(p0, "source1 is null");
       a.c(p1, "source2 is null");
       a.c(p2, "source3 is null");
       a.c(p3, "source4 is null");
       a.c(p4, "source5 is null");
       a.c(p5, "source6 is null");
       a.c(p6, "source7 is null");
       w[] owArray = new w[]{p0,p1,p2,p3,p4,p5,p6};
       return t.combineLatest(Functions.o(p7), t.bufferSize(), owArray);
    }
    public static t combineLatest(w p0,w p1,w p2,w p3,w p4,w p5,k p6){
       a.c(p0, "source1 is null");
       a.c(p1, "source2 is null");
       a.c(p2, "source3 is null");
       a.c(p3, "source4 is null");
       a.c(p4, "source5 is null");
       a.c(p5, "source6 is null");
       w[] owArray = new w[]{p0,p1,p2,p3,p4,p5};
       return t.combineLatest(Functions.n(p6), t.bufferSize(), owArray);
    }
    public static t combineLatest(w p0,w p1,w p2,w p3,w p4,j p5){
       a.c(p0, "source1 is null");
       a.c(p1, "source2 is null");
       a.c(p2, "source3 is null");
       a.c(p3, "source4 is null");
       a.c(p4, "source5 is null");
       w[] owArray = new w[]{p0,p1,p2,p3,p4};
       return t.combineLatest(Functions.m(p5), t.bufferSize(), owArray);
    }
    public static t combineLatest(w p0,w p1,w p2,w p3,i p4){
       a.c(p0, "source1 is null");
       a.c(p1, "source2 is null");
       a.c(p2, "source3 is null");
       a.c(p3, "source4 is null");
       w[] owArray = new w[]{p0,p1,p2,p3};
       return t.combineLatest(Functions.l(p4), t.bufferSize(), owArray);
    }
    public static t combineLatest(w p0,w p1,w p2,h p3){
       a.c(p0, "source1 is null");
       a.c(p1, "source2 is null");
       a.c(p2, "source3 is null");
       w[] owArray = new w[]{p0,p1,p2};
       return t.combineLatest(Functions.k(p3), t.bufferSize(), owArray);
    }
    public static t combineLatest(w p0,w p1,c p2){
       a.c(p0, "source1 is null");
       a.c(p1, "source2 is null");
       w[] owArray = new w[]{p0,p1};
       return t.combineLatest(Functions.j(p2), t.bufferSize(), owArray);
    }
    public static t combineLatest(o p0,int p1,w[] p2){
       return t.combineLatest(p2, p0, p1);
    }
    public static t combineLatest(Iterable p0,o p1){
       return t.combineLatest(p0, p1, t.bufferSize());
    }
    public static t combineLatest(Iterable p0,o p1,int p2){
       a.c(p0, "sources is null");
       a.c(p1, "combiner is null");
       a.d(p2, "bufferSize");
       ObservableCombineLatest observableCo = new ObservableCombineLatest(null, p0, p1, (p2 << 1), false);
       return a.h(p2);
    }
    public static t combineLatest(w[] p0,o p1){
       return t.combineLatest(p0, p1, t.bufferSize());
    }
    public static t combineLatest(w[] p0,o p1,int p2){
       a.c(p0, "sources is null");
       if (!p0.length) {
          return t.empty();
       }
       a.c(p1, "combiner is null");
       a.d(p2, "bufferSize");
       ObservableCombineLatest observableCo = new ObservableCombineLatest(p0, null, p1, (p2 << 1), false);
       return a.h(p2);
    }
    public static t combineLatestDelayError(o p0,int p1,w[] p2){
       return t.combineLatestDelayError(p2, p0, p1);
    }
    public static t combineLatestDelayError(Iterable p0,o p1){
       return t.combineLatestDelayError(p0, p1, t.bufferSize());
    }
    public static t combineLatestDelayError(Iterable p0,o p1,int p2){
       a.c(p0, "sources is null");
       a.c(p1, "combiner is null");
       a.d(p2, "bufferSize");
       ObservableCombineLatest observableCo = new ObservableCombineLatest(null, p0, p1, (p2 << 1), true);
       return a.h(p2);
    }
    public static t combineLatestDelayError(w[] p0,o p1){
       return t.combineLatestDelayError(p0, p1, t.bufferSize());
    }
    public static t combineLatestDelayError(w[] p0,o p1,int p2){
       a.d(p2, "bufferSize");
       a.c(p1, "combiner is null");
       if (!p0.length) {
          return t.empty();
       }
       ObservableCombineLatest observableCo = new ObservableCombineLatest(p0, null, p1, (p2 << 1), true);
       return a.h(p2);
    }
    public static t concat(w p0){
       return t.concat(p0, t.bufferSize());
    }
    public static t concat(w p0,int p1){
       a.c(p0, "sources is null");
       a.d(p1, "prefetch");
       return a.h(new ObservableConcatMap(p0, Functions.e(), p1, ErrorMode.IMMEDIATE));
    }
    public static t concat(w p0,w p1){
       a.c(p0, "source1 is null");
       a.c(p1, "source2 is null");
       w[] owArray = new w[]{p0,p1};
       return t.concatArray(owArray);
    }
    public static t concat(w p0,w p1,w p2){
       a.c(p0, "source1 is null");
       a.c(p1, "source2 is null");
       a.c(p2, "source3 is null");
       w[] owArray = new w[]{p0,p1,p2};
       return t.concatArray(owArray);
    }
    public static t concat(w p0,w p1,w p2,w p3){
       a.c(p0, "source1 is null");
       a.c(p1, "source2 is null");
       a.c(p2, "source3 is null");
       a.c(p3, "source4 is null");
       w[] owArray = new w[]{p0,p1,p2,p3};
       return t.concatArray(owArray);
    }
    public static t concat(Iterable p0){
       a.c(p0, "sources is null");
       return t.fromIterable(p0).concatMapDelayError(Functions.e(), t.bufferSize(), false);
    }
    public static t concatArray(w[] p0){
       if (!p0.length) {
          return t.empty();
       }
       if (p0.length == 1) {
          return t.wrap(p0[0]);
       }
       return a.h(new ObservableConcatMap(t.fromArray(p0), Functions.e(), t.bufferSize(), ErrorMode.BOUNDARY));
    }
    public static t concatArrayDelayError(w[] p0){
       if (!p0.length) {
          return t.empty();
       }
       if (p0.length == 1) {
          return t.wrap(p0[0]);
       }
       return t.concatDelayError(t.fromArray(p0));
    }
    public static t concatArrayEager(int p0,int p1,w[] p2){
       return t.fromArray(p2).concatMapEagerDelayError(Functions.e(), p0, p1, false);
    }
    public static t concatArrayEager(w[] p0){
       return t.concatArrayEager(t.bufferSize(), t.bufferSize(), p0);
    }
    public static t concatDelayError(w p0){
       return t.concatDelayError(p0, t.bufferSize(), true);
    }
    public static t concatDelayError(w p0,int p1,boolean p2){
       a.c(p0, "sources is null");
       a.d(p1, "prefetch is null");
       o oo = Functions.e();
       ErrorMode eND = (p2)? ErrorMode.END: ErrorMode.BOUNDARY;
       return a.h(new ObservableConcatMap(p0, oo, p1, eND));
    }
    public static t concatDelayError(Iterable p0){
       a.c(p0, "sources is null");
       return t.concatDelayError(t.fromIterable(p0));
    }
    public static t concatEager(w p0){
       return t.concatEager(p0, t.bufferSize(), t.bufferSize());
    }
    public static t concatEager(w p0,int p1,int p2){
       return t.wrap(p0).concatMapEager(Functions.e(), p1, p2);
    }
    public static t concatEager(Iterable p0){
       return t.concatEager(p0, t.bufferSize(), t.bufferSize());
    }
    public static t concatEager(Iterable p0,int p1,int p2){
       return t.fromIterable(p0).concatMapEagerDelayError(Functions.e(), p1, p2, false);
    }
    public static t create(g p0){
       a.c(p0, "source is null");
       return a.h(new ObservableCreate(p0));
    }
    public static t defer(Callable p0){
       a.c(p0, "supplier is null");
       return a.h(new s(p0));
    }
    public static t empty(){
       return a.h(f0.b);
    }
    public static t error(Throwable p0){
       a.c(p0, "e is null");
       return t.error(Functions.f(p0));
    }
    public static t error(Callable p0){
       a.c(p0, "errorSupplier is null");
       return a.h(new g0(p0));
    }
    public static t fromArray(Object[] p0){
       a.c(p0, "items is null");
       if (!p0.length) {
          return t.empty();
       }
       if (p0.length == 1) {
          return t.just(p0[0]);
       }
       return a.h(new j0(p0));
    }
    public static t fromCallable(Callable p0){
       a.c(p0, "supplier is null");
       return a.h(new k0(p0));
    }
    public static t fromFuture(Future p0){
       a.c(p0, "future is null");
       return a.h(new l0(p0, 0, null));
    }
    public static t fromFuture(Future p0,long p1,TimeUnit p2){
       a.c(p0, "future is null");
       a.c(p2, "unit is null");
       return a.h(new l0(p0, p1, p2));
    }
    public static t fromFuture(Future p0,long p1,TimeUnit p2,z p3){
       a.c(p3, "scheduler is null");
       return t.fromFuture(p0, p1, p2).subscribeOn(p3);
    }
    public static t fromFuture(Future p0,z p1){
       a.c(p1, "scheduler is null");
       return t.fromFuture(p0).subscribeOn(p1);
    }
    public static t fromIterable(Iterable p0){
       a.c(p0, "source is null");
       return a.h(new m0(p0));
    }
    public static t fromPublisher(b p0){
       a.c(p0, "publisher is null");
       return a.h(new n0(p0));
    }
    public static t generate(g p0){
       a.c(p0, "generator  is null");
       return t.generate(Functions.j, new t0$m(p0), Functions.d());
    }
    public static t generate(Callable p0,b p1){
       a.c(p1, "generator  is null");
       return t.generate(p0, t0.e(p1), Functions.d());
    }
    public static t generate(Callable p0,b p1,g p2){
       a.c(p1, "generator  is null");
       return t.generate(p0, t0.e(p1), p2);
    }
    public static t generate(Callable p0,c p1){
       return t.generate(p0, p1, Functions.d());
    }
    public static t generate(Callable p0,c p1,g p2){
       a.c(p0, "initialState is null");
       a.c(p1, "generator  is null");
       a.c(p2, "disposeState is null");
       return a.h(new p0(p0, p1, p2));
    }
    public static t interval(long p0,long p1,TimeUnit p2){
       return t.interval(p0, p1, p2, b.a());
    }
    public static t interval(long p0,long p1,TimeUnit p2,z p3){
       a.c(p2, "unit is null");
       a.c(p3, "scheduler is null");
       ObservableInterval observableIn = new ObservableInterval(Math.max(0, p0), Math.max(0, p1), p2, p3);
       return a.h(v0);
    }
    public static t interval(long p0,TimeUnit p1){
       return t.interval(p0, p0, p1, b.a());
    }
    public static t interval(long p0,TimeUnit p1,z p2){
       return t.interval(p0, p0, p1, p2);
    }
    public static t intervalRange(long p0,long p1,long p2,long p3,TimeUnit p4){
       return t.intervalRange(p0, p1, p2, p3, p4, b.a());
    }
    public static t intervalRange(long p0,long p1,long p2,long p3,TimeUnit p4,z p5){
       long l = p1;
       long l1 = p2;
       TimeUnit timeUnit = p4;
       z oz = p5;
       long l2 = 0;
       if ((v6 = l - l2) < 0) {
          throw new IllegalArgumentException("count >= 0 required but it was "+l);
       }
       if (!v6) {
          return t.empty().delay(l1, timeUnit, oz);
       }
       long l3 = p0 + (l - 1);
       if (p0 - l2 > 0 && l3 - l2 < 0) {
          throw new IllegalArgumentException("Overflow! start + count is bigger than Long.MAX_VALUE");
       }
       a.c(timeUnit, "unit is null");
       a.c(oz, "scheduler is null");
       ObservableIntervalRange observableIn = new ObservableIntervalRange(p0, l3, Math.max(l2, l1), Math.max(l2, p3), p4, p5);
       return a.h(v11);
    }
    public static t just(Object p0){
       a.c(p0, "The item is null");
       return a.h(new u0(p0));
    }
    public static t just(Object p0,Object p1){
       a.c(p0, "The first item is null");
       a.c(p1, "The second item is null");
       Object[] objArray = new Object[]{p0,p1};
       return t.fromArray(objArray);
    }
    public static t just(Object p0,Object p1,Object p2){
       a.c(p0, "The first item is null");
       a.c(p1, "The second item is null");
       a.c(p2, "The third item is null");
       Object[] objArray = new Object[]{p0,p1,p2};
       return t.fromArray(objArray);
    }
    public static t just(Object p0,Object p1,Object p2,Object p3){
       a.c(p0, "The first item is null");
       a.c(p1, "The second item is null");
       a.c(p2, "The third item is null");
       a.c(p3, "The fourth item is null");
       Object[] objArray = new Object[]{p0,p1,p2,p3};
       return t.fromArray(objArray);
    }
    public static t just(Object p0,Object p1,Object p2,Object p3,Object p4){
       a.c(p0, "The first item is null");
       a.c(p1, "The second item is null");
       a.c(p2, "The third item is null");
       a.c(p3, "The fourth item is null");
       a.c(p4, "The fifth item is null");
       Object[] objArray = new Object[]{p0,p1,p2,p3,p4};
       return t.fromArray(objArray);
    }
    public static t just(Object p0,Object p1,Object p2,Object p3,Object p4,Object p5){
       a.c(p0, "The first item is null");
       a.c(p1, "The second item is null");
       a.c(p2, "The third item is null");
       a.c(p3, "The fourth item is null");
       a.c(p4, "The fifth item is null");
       a.c(p5, "The sixth item is null");
       Object[] objArray = new Object[]{p0,p1,p2,p3,p4,p5};
       return t.fromArray(objArray);
    }
    public static t just(Object p0,Object p1,Object p2,Object p3,Object p4,Object p5,Object p6){
       a.c(p0, "The first item is null");
       a.c(p1, "The second item is null");
       a.c(p2, "The third item is null");
       a.c(p3, "The fourth item is null");
       a.c(p4, "The fifth item is null");
       a.c(p5, "The sixth item is null");
       a.c(p6, "The seventh item is null");
       Object[] objArray = new Object[]{p0,p1,p2,p3,p4,p5,p6};
       return t.fromArray(objArray);
    }
    public static t just(Object p0,Object p1,Object p2,Object p3,Object p4,Object p5,Object p6,Object p7){
       a.c(p0, "The first item is null");
       a.c(p1, "The second item is null");
       a.c(p2, "The third item is null");
       a.c(p3, "The fourth item is null");
       a.c(p4, "The fifth item is null");
       a.c(p5, "The sixth item is null");
       a.c(p6, "The seventh item is null");
       a.c(p7, "The eighth item is null");
       Object[] objArray = new Object[]{p0,p1,p2,p3,p4,p5,p6,p7};
       return t.fromArray(objArray);
    }
    public static t just(Object p0,Object p1,Object p2,Object p3,Object p4,Object p5,Object p6,Object p7,Object p8){
       a.c(p0, "The first item is null");
       a.c(p1, "The second item is null");
       a.c(p2, "The third item is null");
       a.c(p3, "The fourth item is null");
       a.c(p4, "The fifth item is null");
       a.c(p5, "The sixth item is null");
       a.c(p6, "The seventh item is null");
       a.c(p7, "The eighth item is null");
       a.c(p8, "The ninth item is null");
       Object[] objArray = new Object[9];
       objArray[0] = p0;
       objArray[1] = p1;
       objArray[2] = p2;
       objArray[3] = p3;
       objArray[4] = p4;
       objArray[5] = p5;
       objArray[6] = p6;
       objArray[7] = p7;
       objArray[8] = p8;
       return t.fromArray(objArray);
    }
    public static t just(Object p0,Object p1,Object p2,Object p3,Object p4,Object p5,Object p6,Object p7,Object p8,Object p9){
       a.c(p0, "The first item is null");
       a.c(p1, "The second item is null");
       a.c(p2, "The third item is null");
       a.c(p3, "The fourth item is null");
       a.c(p4, "The fifth item is null");
       a.c(p5, "The sixth item is null");
       a.c(p6, "The seventh item is null");
       a.c(p7, "The eighth item is null");
       a.c(p8, "The ninth item is null");
       a.c(p9, "The tenth item is null");
       Object[] objArray = new Object[10];
       objArray[0] = p0;
       objArray[1] = p1;
       objArray[2] = p2;
       objArray[3] = p3;
       objArray[4] = p4;
       objArray[5] = p5;
       objArray[6] = p6;
       objArray[7] = p7;
       objArray[8] = p8;
       objArray[9] = p9;
       return t.fromArray(objArray);
    }
    public static t merge(w p0){
       a.c(p0, "sources is null");
       ObservableFlatMap observableFl = new ObservableFlatMap(p0, Functions.e(), false, Integer.MAX_VALUE, t.bufferSize());
       return a.h(v0);
    }
    public static t merge(w p0,int p1){
       a.c(p0, "sources is null");
       a.d(p1, "maxConcurrency");
       ObservableFlatMap observableFl = new ObservableFlatMap(p0, Functions.e(), false, p1, t.bufferSize());
       return a.h(v0);
    }
    public static t merge(w p0,w p1){
       a.c(p0, "source1 is null");
       a.c(p1, "source2 is null");
       w[] owArray = new w[]{p0,p1};
       return t.fromArray(owArray).flatMap(Functions.e(), 0, 2);
    }
    public static t merge(w p0,w p1,w p2){
       a.c(p0, "source1 is null");
       a.c(p1, "source2 is null");
       a.c(p2, "source3 is null");
       w[] owArray = new w[]{p0,p1,p2};
       return t.fromArray(owArray).flatMap(Functions.e(), 0, 3);
    }
    public static t merge(w p0,w p1,w p2,w p3){
       a.c(p0, "source1 is null");
       a.c(p1, "source2 is null");
       a.c(p2, "source3 is null");
       a.c(p3, "source4 is null");
       w[] owArray = new w[]{p0,p1,p2,p3};
       return t.fromArray(owArray).flatMap(Functions.e(), 0, 4);
    }
    public static t merge(Iterable p0){
       return t.fromIterable(p0).flatMap(Functions.e());
    }
    public static t merge(Iterable p0,int p1){
       return t.fromIterable(p0).flatMap(Functions.e(), p1);
    }
    public static t merge(Iterable p0,int p1,int p2){
       return t.fromIterable(p0).flatMap(Functions.e(), false, p1, p2);
    }
    public static t mergeArray(int p0,int p1,w[] p2){
       return t.fromArray(p2).flatMap(Functions.e(), false, p0, p1);
    }
    public static t mergeArray(w[] p0){
       return t.fromArray(p0).flatMap(Functions.e(), p0.length);
    }
    public static t mergeArrayDelayError(int p0,int p1,w[] p2){
       return t.fromArray(p2).flatMap(Functions.e(), true, p0, p1);
    }
    public static t mergeArrayDelayError(w[] p0){
       return t.fromArray(p0).flatMap(Functions.e(), true, p0.length);
    }
    public static t mergeDelayError(w p0){
       a.c(p0, "sources is null");
       ObservableFlatMap observableFl = new ObservableFlatMap(p0, Functions.e(), true, Integer.MAX_VALUE, t.bufferSize());
       return a.h(v0);
    }
    public static t mergeDelayError(w p0,int p1){
       a.c(p0, "sources is null");
       a.d(p1, "maxConcurrency");
       ObservableFlatMap observableFl = new ObservableFlatMap(p0, Functions.e(), true, p1, t.bufferSize());
       return a.h(v0);
    }
    public static t mergeDelayError(w p0,w p1){
       a.c(p0, "source1 is null");
       a.c(p1, "source2 is null");
       w[] owArray = new w[]{p0,p1};
       return t.fromArray(owArray).flatMap(Functions.e(), 1, 2);
    }
    public static t mergeDelayError(w p0,w p1,w p2){
       a.c(p0, "source1 is null");
       a.c(p1, "source2 is null");
       a.c(p2, "source3 is null");
       w[] owArray = new w[]{p0,p1,p2};
       return t.fromArray(owArray).flatMap(Functions.e(), 1, 3);
    }
    public static t mergeDelayError(w p0,w p1,w p2,w p3){
       a.c(p0, "source1 is null");
       a.c(p1, "source2 is null");
       a.c(p2, "source3 is null");
       a.c(p3, "source4 is null");
       w[] owArray = new w[]{p0,p1,p2,p3};
       return t.fromArray(owArray).flatMap(Functions.e(), 1, 4);
    }
    public static t mergeDelayError(Iterable p0){
       return t.fromIterable(p0).flatMap(Functions.e(), true);
    }
    public static t mergeDelayError(Iterable p0,int p1){
       return t.fromIterable(p0).flatMap(Functions.e(), true, p1);
    }
    public static t mergeDelayError(Iterable p0,int p1,int p2){
       return t.fromIterable(p0).flatMap(Functions.e(), true, p1, p2);
    }
    public static t never(){
       return a.h(b1.b);
    }
    public static t range(int p0,int p1){
       if (p1 < 0) {
          throw new IllegalArgumentException("count >= 0 required but it was "+p1);
       }
       if (!p1) {
          return t.empty();
       }
       if (p1 == 1) {
          return t.just(Integer.valueOf(p0));
       }
       if (((long)p0 + (long)(p1 - 1)) - 0x7fffffff <= 0) {
          return a.h(new ObservableRange(p0, p1));
       }
       throw new IllegalArgumentException("Integer overflow");
    }
    public static t rangeLong(long p0,long p1){
       ObservableRangeLong observableRa = null;
       if ((v2 = p1 - observableRa) < 0) {
          throw new IllegalArgumentException("count >= 0 required but it was "+p1);
       }
       if (!v2) {
          return t.empty();
       }
       long l = 1;
       if (!p1 - l) {
          return t.just(Long.valueOf(p0));
       }
       l = (p1 - l) + p0;
       if (p0 - observableRa <= 0 || l - observableRa >= 0) {
          return a.h(new ObservableRangeLong(p0, p1));
       }
       throw new IllegalArgumentException("Overflow! start + count is bigger than Long.MAX_VALUE");
    }
    public static a0 sequenceEqual(w p0,w p1){
       return t.sequenceEqual(p0, p1, a.b(), t.bufferSize());
    }
    public static a0 sequenceEqual(w p0,w p1,int p2){
       return t.sequenceEqual(p0, p1, a.b(), p2);
    }
    public static a0 sequenceEqual(w p0,w p1,d p2){
       return t.sequenceEqual(p0, p1, p2, t.bufferSize());
    }
    public static a0 sequenceEqual(w p0,w p1,d p2,int p3){
       a.c(p0, "source1 is null");
       a.c(p1, "source2 is null");
       a.c(p2, "isEqual is null");
       a.d(p3, "bufferSize");
       return a.i(new ObservableSequenceEqualSingle(p0, p1, p2, p3));
    }
    public static t switchOnNext(w p0){
       return t.switchOnNext(p0, t.bufferSize());
    }
    public static t switchOnNext(w p0,int p1){
       a.c(p0, "sources is null");
       a.d(p1, "bufferSize");
       return a.h(new ObservableSwitchMap(p0, Functions.e(), p1, false));
    }
    public static t switchOnNextDelayError(w p0){
       return t.switchOnNextDelayError(p0, t.bufferSize());
    }
    public static t switchOnNextDelayError(w p0,int p1){
       a.c(p0, "sources is null");
       a.d(p1, "prefetch");
       return a.h(new ObservableSwitchMap(p0, Functions.e(), p1, true));
    }
    public static t timer(long p0,TimeUnit p1){
       return t.timer(p0, p1, b.a());
    }
    public static t timer(long p0,TimeUnit p1,z p2){
       a.c(p1, "unit is null");
       a.c(p2, "scheduler is null");
       return a.h(new ObservableTimer(Math.max(p0, 0), p1, p2));
    }
    public static t unsafeCreate(w p0){
       a.c(p0, "source is null");
       a.c(p0, "onSubscribe is null");
       if (!p0 instanceof t) {
          return a.h(new o0(p0));
       }
       throw new IllegalArgumentException("unsafeCreate\(Observable\) should be upgraded");
    }
    public static t using(Callable p0,o p1,g p2){
       return t.using(p0, p1, p2, true);
    }
    public static t using(Callable p0,o p1,g p2,boolean p3){
       a.c(p0, "resourceSupplier is null");
       a.c(p1, "sourceSupplier is null");
       a.c(p2, "disposer is null");
       return a.h(new ObservableUsing(p0, p1, p2, p3));
    }
    public static t wrap(w p0){
       a.c(p0, "source is null");
       if (p0 instanceof t) {
          return a.h(p0);
       }
       return a.h(new o0(p0));
    }
    public static t zip(w p0,w p1,w p2,w p3,w p4,w p5,w p6,w p7,w p8,n p9){
       a.c(p0, "source1 is null");
       a.c(p1, "source2 is null");
       a.c(p2, "source3 is null");
       a.c(p3, "source4 is null");
       a.c(p4, "source5 is null");
       a.c(p5, "source6 is null");
       a.c(p6, "source7 is null");
       a.c(p7, "source8 is null");
       a.c(p8, "source9 is null");
       w[] owArray = new w[9];
       owArray[0] = p0;
       owArray[1] = p1;
       owArray[2] = p2;
       owArray[3] = p3;
       owArray[4] = p4;
       owArray[5] = p5;
       owArray[6] = p6;
       owArray[7] = p7;
       owArray[8] = p8;
       return t.zipArray(Functions.q(p9), 0, t.bufferSize(), owArray);
    }
    public static t zip(w p0,w p1,w p2,w p3,w p4,w p5,w p6,w p7,m p8){
       a.c(p0, "source1 is null");
       a.c(p1, "source2 is null");
       a.c(p2, "source3 is null");
       a.c(p3, "source4 is null");
       a.c(p4, "source5 is null");
       a.c(p5, "source6 is null");
       a.c(p6, "source7 is null");
       a.c(p7, "source8 is null");
       w[] owArray = new w[]{p0,p1,p2,p3,p4,p5,p6,p7};
       return t.zipArray(Functions.p(p8), 0, t.bufferSize(), owArray);
    }
    public static t zip(w p0,w p1,w p2,w p3,w p4,w p5,w p6,l p7){
       a.c(p0, "source1 is null");
       a.c(p1, "source2 is null");
       a.c(p2, "source3 is null");
       a.c(p3, "source4 is null");
       a.c(p4, "source5 is null");
       a.c(p5, "source6 is null");
       a.c(p6, "source7 is null");
       w[] owArray = new w[]{p0,p1,p2,p3,p4,p5,p6};
       return t.zipArray(Functions.o(p7), 0, t.bufferSize(), owArray);
    }
    public static t zip(w p0,w p1,w p2,w p3,w p4,w p5,k p6){
       a.c(p0, "source1 is null");
       a.c(p1, "source2 is null");
       a.c(p2, "source3 is null");
       a.c(p3, "source4 is null");
       a.c(p4, "source5 is null");
       a.c(p5, "source6 is null");
       w[] owArray = new w[]{p0,p1,p2,p3,p4,p5};
       return t.zipArray(Functions.n(p6), 0, t.bufferSize(), owArray);
    }
    public static t zip(w p0,w p1,w p2,w p3,w p4,j p5){
       a.c(p0, "source1 is null");
       a.c(p1, "source2 is null");
       a.c(p2, "source3 is null");
       a.c(p3, "source4 is null");
       a.c(p4, "source5 is null");
       w[] owArray = new w[]{p0,p1,p2,p3,p4};
       return t.zipArray(Functions.m(p5), 0, t.bufferSize(), owArray);
    }
    public static t zip(w p0,w p1,w p2,w p3,i p4){
       a.c(p0, "source1 is null");
       a.c(p1, "source2 is null");
       a.c(p2, "source3 is null");
       a.c(p3, "source4 is null");
       w[] owArray = new w[]{p0,p1,p2,p3};
       return t.zipArray(Functions.l(p4), 0, t.bufferSize(), owArray);
    }
    public static t zip(w p0,w p1,w p2,h p3){
       a.c(p0, "source1 is null");
       a.c(p1, "source2 is null");
       a.c(p2, "source3 is null");
       w[] owArray = new w[]{p0,p1,p2};
       return t.zipArray(Functions.k(p3), 0, t.bufferSize(), owArray);
    }
    public static t zip(w p0,w p1,c p2){
       a.c(p0, "source1 is null");
       a.c(p1, "source2 is null");
       w[] owArray = new w[]{p0,p1};
       return t.zipArray(Functions.j(p2), 0, t.bufferSize(), owArray);
    }
    public static t zip(w p0,w p1,c p2,boolean p3){
       a.c(p0, "source1 is null");
       a.c(p1, "source2 is null");
       w[] owArray = new w[]{p0,p1};
       return t.zipArray(Functions.j(p2), p3, t.bufferSize(), owArray);
    }
    public static t zip(w p0,w p1,c p2,boolean p3,int p4){
       a.c(p0, "source1 is null");
       a.c(p1, "source2 is null");
       w[] owArray = new w[]{p0,p1};
       return t.zipArray(Functions.j(p2), p3, p4, owArray);
    }
    public static t zip(w p0,o p1){
       a.c(p1, "zipper is null");
       a.c(p0, "sources is null");
       return a.h(new v1(p0, 16).flatMap(new t0$o(p1)));
    }
    public static t zip(Iterable p0,o p1){
       a.c(p1, "zipper is null");
       a.c(p0, "sources is null");
       ObservableZip observableZi = new ObservableZip(null, p0, p1, t.bufferSize(), false);
       return a.h(v0);
    }
    public static t zipArray(o p0,boolean p1,int p2,w[] p3){
       if (!p3.length) {
          return t.empty();
       }
       a.c(p0, "zipper is null");
       a.d(p2, "bufferSize");
       ObservableZip observableZi = new ObservableZip(p3, null, p0, p2, p1);
       return a.h(v0);
    }
    public static t zipIterable(Iterable p0,o p1,boolean p2,int p3){
       a.c(p1, "zipper is null");
       a.c(p0, "sources is null");
       a.d(p3, "bufferSize");
       ObservableZip observableZi = new ObservableZip(null, p0, p1, p3, p2);
       return a.h(v0);
    }
    public final a0 all(r p0){
       a.c(p0, "predicate is null");
       return a.i(new f(this, p0));
    }
    public final t ambWith(w p0){
       a.c(p0, "other is null");
       w[] owArray = new w[]{this,p0};
       return t.ambArray(owArray);
    }
    public final a0 any(r p0){
       a.c(p0, "predicate is null");
       return a.i(new h(this, p0));
    }
    public final Object as(u p0){
       a.c(p0, "converter is null");
       return p0.apply(this);
    }
    public final Object blockingFirst(){
       d uod = new d();
       this.subscribe(uod);
       Object obj = uod.a();
       if (obj != null) {
          return obj;
       }
       throw new NoSuchElementException();
    }
    public final Object blockingFirst(Object p0){
       d uod = new d();
       this.subscribe(uod);
       Object obj = uod.a();
       if (obj != null) {
          p0 = obj;
       }
       return p0;
    }
    public final void blockingForEach(g p0){
       Iterator iterator = this.blockingIterable().iterator();
       while (iterator.hasNext()) {
          p0.accept(iterator.next());
       }
       return;
    }
    public final Iterable blockingIterable(){
       return this.blockingIterable(t.bufferSize());
    }
    public final Iterable blockingIterable(int p0){
       a.d(p0, "bufferSize");
       return new BlockingObservableIterable(this, p0);
    }
    public final Object blockingLast(){
       e uoe = new e();
       this.subscribe(uoe);
       Object obj = uoe.a();
       if (obj != null) {
          return obj;
       }
       throw new NoSuchElementException();
    }
    public final Object blockingLast(Object p0){
       e uoe = new e();
       this.subscribe(uoe);
       Object obj = uoe.a();
       if (obj != null) {
          p0 = obj;
       }
       return p0;
    }
    public final Iterable blockingLatest(){
       return new b(this);
    }
    public final Iterable blockingMostRecent(Object p0){
       return new c(this, p0);
    }
    public final Iterable blockingNext(){
       return new d(this);
    }
    public final Object blockingSingle(){
       Object obj = this.singleElement().e();
       if (obj != null) {
          return obj;
       }
       throw new NoSuchElementException();
    }
    public final Object blockingSingle(Object p0){
       return this.single(p0).e();
    }
    public final void blockingSubscribe(){
       d uod;
       try{
          uod = new d();
          this.subscribe(new LambdaObserver(Functions.d(), uod, uod, Functions.d()));
          if (!uod.getCount()) {
          }else {
             c.a();
             uod.await();
          }
          uod = uod.b;
          if (uod == null) {
             return;
          }else {
             throw ExceptionHelper.d(uod);
          }
       }catch(java.lang.InterruptedException e0){
          new LambdaObserver(Functions.d(), uod, uod, Functions.d()).dispose();
          Thread.currentThread().interrupt();
          throw new IllegalStateException("Interrupted while waiting for subscription to complete.", e0);
       }
    }
    public final void blockingSubscribe(y p0){
       j.a(this, p0);
    }
    public final void blockingSubscribe(g p0){
       j.b(this, p0, Functions.f, Functions.c);
    }
    public final void blockingSubscribe(g p0,g p1){
       j.b(this, p0, p1, Functions.c);
    }
    public final void blockingSubscribe(g p0,g p1,a p2){
       j.b(this, p0, p1, p2);
    }
    public final t buffer(int p0){
       return this.buffer(p0, p0);
    }
    public final t buffer(int p0,int p1){
       return this.buffer(p0, p1, ArrayListSupplier.asCallable());
    }
    public final t buffer(int p0,int p1,Callable p2){
       a.d(p0, "count");
       a.d(p1, "skip");
       a.c(p2, "bufferSupplier is null");
       return a.h(new ObservableBuffer(this, p0, p1, p2));
    }
    public final t buffer(int p0,Callable p1){
       return this.buffer(p0, p0, p1);
    }
    public final t buffer(long p0,long p1,TimeUnit p2){
       return this.buffer(p0, p1, p2, b.a(), ArrayListSupplier.asCallable());
    }
    public final t buffer(long p0,long p1,TimeUnit p2,z p3){
       return this.buffer(p0, p1, p2, p3, ArrayListSupplier.asCallable());
    }
    public final t buffer(long p0,long p1,TimeUnit p2,z p3,Callable p4){
       Object obj = p2;
       a.c(obj, "unit is null");
       Object obj1 = p3;
       a.c(obj1, "scheduler is null");
       Object obj2 = p4;
       a.c(obj2, "bufferSupplier is null");
       m om = new m(this, p0, p1, obj, obj1, obj2, Integer.MAX_VALUE, false);
       return a.h(v0);
    }
    public final t buffer(long p0,TimeUnit p1){
       return this.buffer(p0, p1, b.a(), Integer.MAX_VALUE);
    }
    public final t buffer(long p0,TimeUnit p1,int p2){
       return this.buffer(p0, p1, b.a(), p2);
    }
    public final t buffer(long p0,TimeUnit p1,z p2){
       return this.buffer(p0, p1, p2, Integer.MAX_VALUE, ArrayListSupplier.asCallable(), false);
    }
    public final t buffer(long p0,TimeUnit p1,z p2,int p3){
       return this.buffer(p0, p1, p2, p3, ArrayListSupplier.asCallable(), false);
    }
    public final t buffer(long p0,TimeUnit p1,z p2,int p3,Callable p4,boolean p5){
       a.c(p1, "unit is null");
       Object obj = p2;
       a.c(obj, "scheduler is null");
       Object obj1 = p4;
       a.c(obj1, "bufferSupplier is null");
       int i = p3;
       a.d(i, "count");
       m om = new m(this, p0, p0, p1, obj, obj1, i, p5);
       return a.h(v0);
    }
    public final t buffer(w p0){
       return this.buffer(p0, ArrayListSupplier.asCallable());
    }
    public final t buffer(w p0,int p1){
       a.d(p1, "initialCapacity");
       return this.buffer(p0, Functions.b(p1));
    }
    public final t buffer(w p0,o p1){
       return this.buffer(p0, p1, ArrayListSupplier.asCallable());
    }
    public final t buffer(w p0,o p1,Callable p2){
       a.c(p0, "openingIndicator is null");
       a.c(p1, "closingIndicator is null");
       a.c(p2, "bufferSupplier is null");
       return a.h(new ObservableBufferBoundary(this, p0, p1, p2));
    }
    public final t buffer(w p0,Callable p1){
       a.c(p0, "boundary is null");
       a.c(p1, "bufferSupplier is null");
       return a.h(new l(this, p0, p1));
    }
    public final t buffer(Callable p0){
       return this.buffer(p0, ArrayListSupplier.asCallable());
    }
    public final t buffer(Callable p0,Callable p1){
       a.c(p0, "boundarySupplier is null");
       a.c(p1, "bufferSupplier is null");
       return a.h(new k(this, p0, p1));
    }
    public final t cache(){
       return ObservableCache.b(this, 16);
    }
    public final t cacheWithInitialCapacity(int p0){
       return ObservableCache.b(this, p0);
    }
    public final t cast(Class p0){
       a.c(p0, "clazz is null");
       return this.map(new Functions$l(p0));
    }
    public final a0 collect(Callable p0,b p1){
       a.c(p0, "initialValueSupplier is null");
       a.c(p1, "collector is null");
       return a.i(new o(this, p0, p1));
    }
    public final a0 collectInto(Object p0,b p1){
       a.c(p0, "initialValue is null");
       return this.collect(Functions.f(p0), p1);
    }
    public final t compose(x p0){
       a.c(p0, "composer is null");
       return t.wrap(p0.apply(this));
    }
    public final t concatMap(o p0){
       return this.concatMap(p0, 2);
    }
    public final t concatMap(o p0,int p1){
       a.c(p0, "mapper is null");
       a.d(p1, "prefetch");
       if (!this instanceof m) {
          return a.h(new ObservableConcatMap(this, p0, p1, ErrorMode.IMMEDIATE));
       }
       Object obj = this.call();
       if (obj == null) {
          return t.empty();
       }
       return ObservableScalarXMap.a(obj, p0);
    }
    public final a concatMapCompletable(o p0){
       return this.concatMapCompletable(p0, 2);
    }
    public final a concatMapCompletable(o p0,int p1){
       a.c(p0, "mapper is null");
       a.d(p1, "capacityHint");
       return a.e(new ObservableConcatMapCompletable(this, p0, ErrorMode.IMMEDIATE, p1));
    }
    public final a concatMapCompletableDelayError(o p0){
       return this.concatMapCompletableDelayError(p0, true, 2);
    }
    public final a concatMapCompletableDelayError(o p0,boolean p1){
       return this.concatMapCompletableDelayError(p0, p1, 2);
    }
    public final a concatMapCompletableDelayError(o p0,boolean p1,int p2){
       a.c(p0, "mapper is null");
       a.d(p2, "prefetch");
       ErrorMode eND = (p1)? ErrorMode.END: ErrorMode.BOUNDARY;
       return a.e(new ObservableConcatMapCompletable(this, p0, eND, p2));
    }
    public final t concatMapDelayError(o p0){
       return this.concatMapDelayError(p0, t.bufferSize(), true);
    }
    public final t concatMapDelayError(o p0,int p1,boolean p2){
       ErrorMode eND;
       a.c(p0, "mapper is null");
       a.d(p1, "prefetch");
       if (this instanceof m) {
          Object obj = this.call();
          if (obj == null) {
             return t.empty();
          }else {
             return ObservableScalarXMap.a(obj, p0);
          }
       }else if(p2){
          eND = ErrorMode.END;
       }else {
          eND = ErrorMode.BOUNDARY;
       }
       return a.h(new ObservableConcatMap(this, p0, p1, eND));
    }
    public final t concatMapEager(o p0){
       return this.concatMapEager(p0, Integer.MAX_VALUE, t.bufferSize());
    }
    public final t concatMapEager(o p0,int p1,int p2){
       a.c(p0, "mapper is null");
       a.d(p1, "maxConcurrency");
       a.d(p2, "prefetch");
       ObservableConcatMapEager observableCo = new ObservableConcatMapEager(this, p0, ErrorMode.IMMEDIATE, p1, p2);
       return a.h(v0);
    }
    public final t concatMapEagerDelayError(o p0,int p1,int p2,boolean p3){
       a.c(p0, "mapper is null");
       a.d(p1, "maxConcurrency");
       a.d(p2, "prefetch");
       ErrorMode eND = (p3)? ErrorMode.END: ErrorMode.BOUNDARY;
       ObservableConcatMapEager observableCo = new ObservableConcatMapEager(this, p0, eND, p1, p2);
       return a.h(v0);
    }
    public final t concatMapEagerDelayError(o p0,boolean p1){
       return this.concatMapEagerDelayError(p0, Integer.MAX_VALUE, t.bufferSize(), p1);
    }
    public final t concatMapIterable(o p0){
       a.c(p0, "mapper is null");
       return a.h(new i0(this, p0));
    }
    public final t concatMapIterable(o p0,int p1){
       a.c(p0, "mapper is null");
       a.d(p1, "prefetch");
       return this.concatMap(t0.a(p0), p1);
    }
    public final t concatMapMaybe(o p0){
       return this.concatMapMaybe(p0, 2);
    }
    public final t concatMapMaybe(o p0,int p1){
       a.c(p0, "mapper is null");
       a.d(p1, "prefetch");
       return a.h(new ObservableConcatMapMaybe(this, p0, ErrorMode.IMMEDIATE, p1));
    }
    public final t concatMapMaybeDelayError(o p0){
       return this.concatMapMaybeDelayError(p0, true, 2);
    }
    public final t concatMapMaybeDelayError(o p0,boolean p1){
       return this.concatMapMaybeDelayError(p0, p1, 2);
    }
    public final t concatMapMaybeDelayError(o p0,boolean p1,int p2){
       a.c(p0, "mapper is null");
       a.d(p2, "prefetch");
       ErrorMode eND = (p1)? ErrorMode.END: ErrorMode.BOUNDARY;
       return a.h(new ObservableConcatMapMaybe(this, p0, eND, p2));
    }
    public final t concatMapSingle(o p0){
       return this.concatMapSingle(p0, 2);
    }
    public final t concatMapSingle(o p0,int p1){
       a.c(p0, "mapper is null");
       a.d(p1, "prefetch");
       return a.h(new ObservableConcatMapSingle(this, p0, ErrorMode.IMMEDIATE, p1));
    }
    public final t concatMapSingleDelayError(o p0){
       return this.concatMapSingleDelayError(p0, true, 2);
    }
    public final t concatMapSingleDelayError(o p0,boolean p1){
       return this.concatMapSingleDelayError(p0, p1, 2);
    }
    public final t concatMapSingleDelayError(o p0,boolean p1,int p2){
       a.c(p0, "mapper is null");
       a.d(p2, "prefetch");
       ErrorMode eND = (p1)? ErrorMode.END: ErrorMode.BOUNDARY;
       return a.h(new ObservableConcatMapSingle(this, p0, eND, p2));
    }
    public final t concatWith(e0 p0){
       a.c(p0, "other is null");
       return a.h(new ObservableConcatWithSingle(this, p0));
    }
    public final t concatWith(e p0){
       a.c(p0, "other is null");
       return a.h(new ObservableConcatWithCompletable(this, p0));
    }
    public final t concatWith(q p0){
       a.c(p0, "other is null");
       return a.h(new ObservableConcatWithMaybe(this, p0));
    }
    public final t concatWith(w p0){
       a.c(p0, "other is null");
       return t.concat(this, p0);
    }
    public final a0 contains(Object p0){
       a.c(p0, "element is null");
       return this.any(new Functions$r(p0));
    }
    public final a0 count(){
       return a.i(new q(this));
    }
    public final t debounce(long p0,TimeUnit p1){
       return this.debounce(p0, p1, b.a());
    }
    public final t debounce(long p0,TimeUnit p1,z p2){
       a.c(p1, "unit is null");
       a.c(p2, "scheduler is null");
       ObservableDebounceTimed observableDe = new ObservableDebounceTimed(this, p0, p1, p2);
       return a.h(v0);
    }
    public final t debounce(o p0){
       a.c(p0, "debounceSelector is null");
       return a.h(new r(this, p0));
    }
    public final t defaultIfEmpty(Object p0){
       a.c(p0, "defaultItem is null");
       return this.switchIfEmpty(t.just(p0));
    }
    public final t delay(long p0,TimeUnit p1){
       return this.delay(p0, p1, b.a(), false);
    }
    public final t delay(long p0,TimeUnit p1,z p2){
       return this.delay(p0, p1, p2, false);
    }
    public final t delay(long p0,TimeUnit p1,z p2,boolean p3){
       a.c(p1, "unit is null");
       a.c(p2, "scheduler is null");
       t ot = new t(this, p0, p1, p2, p3);
       return a.h(v0);
    }
    public final t delay(long p0,TimeUnit p1,boolean p2){
       return this.delay(p0, p1, b.a(), p2);
    }
    public final t delay(w p0,o p1){
       return this.delaySubscription(p0).delay(p1);
    }
    public final t delay(o p0){
       a.c(p0, "itemDelay is null");
       return this.flatMap(new t0$f(p0));
    }
    public final t delaySubscription(long p0,TimeUnit p1){
       return this.delaySubscription(p0, p1, b.a());
    }
    public final t delaySubscription(long p0,TimeUnit p1,z p2){
       return this.delaySubscription(t.timer(p0, p1, p2));
    }
    public final t delaySubscription(w p0){
       a.c(p0, "other is null");
       return a.h(new u(this, p0));
    }
    public final t dematerialize(){
       return a.h(new v(this));
    }
    public final t distinct(){
       return this.distinct(Functions.e(), Functions.c());
    }
    public final t distinct(o p0){
       return this.distinct(p0, Functions.c());
    }
    public final t distinct(o p0,Callable p1){
       a.c(p0, "keySelector is null");
       a.c(p1, "collectionSupplier is null");
       return a.h(new x(this, p0, p1));
    }
    public final t distinctUntilChanged(){
       return this.distinctUntilChanged(Functions.e());
    }
    public final t distinctUntilChanged(d p0){
       a.c(p0, "comparer is null");
       return a.h(new y(this, Functions.e(), p0));
    }
    public final t distinctUntilChanged(o p0){
       a.c(p0, "keySelector is null");
       return a.h(new y(this, p0, a.b()));
    }
    public final t doAfterNext(g p0){
       a.c(p0, "onAfterNext is null");
       return a.h(new z(this, p0));
    }
    public final t doAfterTerminate(a p0){
       a.c(p0, "onFinally is null");
       return this.doOnEach(Functions.d(), Functions.d(), Functions.c, p0);
    }
    public final t doFinally(a p0){
       a.c(p0, "onFinally is null");
       return a.h(new ObservableDoFinally(this, p0));
    }
    public final t doOnComplete(a p0){
       return this.doOnEach(Functions.d(), Functions.d(), p0, Functions.c);
    }
    public final t doOnDispose(a p0){
       return this.doOnLifecycle(Functions.d(), p0);
    }
    public final t doOnEach(y p0){
       a.c(p0, "observer is null");
       return this.doOnEach(new t0$i(p0), new t0$h(p0), new t0$g(p0), Functions.c);
    }
    public final t doOnEach(g p0){
       a.c(p0, "consumer is null");
       return this.doOnEach(new Functions$c0(p0), new Functions$b0(p0), new Functions$a0(p0), Functions.c);
    }
    public final t doOnEach(g p0,g p1,a p2,a p3){
       a.c(p0, "onNext is null");
       a.c(p1, "onError is null");
       a.c(p2, "onComplete is null");
       a.c(p3, "onAfterTerminate is null");
       a0 uoa0 = new a0(this, p0, p1, p2, p3);
       return a.h(v0);
    }
    public final t doOnError(g p0){
       return this.doOnEach(Functions.d(), p0, Functions.c, Functions.c);
    }
    public final t doOnLifecycle(g p0,a p1){
       a.c(p0, "onSubscribe is null");
       a.c(p1, "onDispose is null");
       return a.h(new b0(this, p0, p1));
    }
    public final t doOnNext(g p0){
       return this.doOnEach(p0, Functions.d(), Functions.c, Functions.c);
    }
    public final t doOnSubscribe(g p0){
       return this.doOnLifecycle(p0, Functions.c);
    }
    public final t doOnTerminate(a p0){
       a.c(p0, "onTerminate is null");
       return this.doOnEach(Functions.d(), new Functions$a(p0), p0, Functions.c);
    }
    public final a0 elementAt(long p0,Object p1){
       if (p0 - null < 0) {
          throw new IndexOutOfBoundsException("index >= 0 required but it was "+p0);
       }
       a.c(p1, "defaultItem is null");
       return a.i(new e0(this, p0, p1));
    }
    public final m elementAt(long p0){
       if (p0 - null >= 0) {
          return a.g(new d0(this, p0));
       }
       throw new IndexOutOfBoundsException("index >= 0 required but it was "+p0);
    }
    public final a0 elementAtOrError(long p0){
       if (p0 - null >= 0) {
          return a.i(new e0(this, p0, null));
       }
       throw new IndexOutOfBoundsException("index >= 0 required but it was "+p0);
    }
    public final t filter(r p0){
       a.c(p0, "predicate is null");
       return a.h(new h0(this, p0));
    }
    public final a0 first(Object p0){
       return this.elementAt(0, p0);
    }
    public final m firstElement(){
       return this.elementAt(0);
    }
    public final a0 firstOrError(){
       return this.elementAtOrError(0);
    }
    public final t flatMap(o p0){
       return this.flatMap(p0, false);
    }
    public final t flatMap(o p0,int p1){
       return this.flatMap(p0, false, p1, t.bufferSize());
    }
    public final t flatMap(o p0,c p1){
       return this.flatMap(p0, p1, false, t.bufferSize(), t.bufferSize());
    }
    public final t flatMap(o p0,c p1,int p2){
       return this.flatMap(p0, p1, false, p2, t.bufferSize());
    }
    public final t flatMap(o p0,c p1,boolean p2){
       return this.flatMap(p0, p1, p2, t.bufferSize(), t.bufferSize());
    }
    public final t flatMap(o p0,c p1,boolean p2,int p3){
       return this.flatMap(p0, p1, p2, p3, t.bufferSize());
    }
    public final t flatMap(o p0,c p1,boolean p2,int p3,int p4){
       a.c(p0, "mapper is null");
       a.c(p1, "combiner is null");
       return this.flatMap(new t0$e(p1, p0), p2, p3, p4);
    }
    public final t flatMap(o p0,o p1,Callable p2){
       a.c(p0, "onNextMapper is null");
       a.c(p1, "onErrorMapper is null");
       a.c(p2, "onCompleteSupplier is null");
       return t.merge(new z0(this, p0, p1, p2));
    }
    public final t flatMap(o p0,o p1,Callable p2,int p3){
       a.c(p0, "onNextMapper is null");
       a.c(p1, "onErrorMapper is null");
       a.c(p2, "onCompleteSupplier is null");
       return t.merge(new z0(this, p0, p1, p2), p3);
    }
    public final t flatMap(o p0,boolean p1){
       return this.flatMap(p0, p1, Integer.MAX_VALUE);
    }
    public final t flatMap(o p0,boolean p1,int p2){
       return this.flatMap(p0, p1, p2, t.bufferSize());
    }
    public final t flatMap(o p0,boolean p1,int p2,int p3){
       a.c(p0, "mapper is null");
       a.d(p2, "maxConcurrency");
       a.d(p3, "bufferSize");
       if (this instanceof m) {
          Object obj = this.call();
          if (obj == null) {
             return t.empty();
          }
          return ObservableScalarXMap.a(obj, p0);
       }else {
          ObservableFlatMap observableFl = new ObservableFlatMap(this, p0, p1, p2, p3);
          return a.h(v6);
       }
    }
    public final a flatMapCompletable(o p0){
       return this.flatMapCompletable(p0, false);
    }
    public final a flatMapCompletable(o p0,boolean p1){
       a.c(p0, "mapper is null");
       return a.e(new ObservableFlatMapCompletableCompletable(this, p0, p1));
    }
    public final t flatMapIterable(o p0){
       a.c(p0, "mapper is null");
       return a.h(new i0(this, p0));
    }
    public final t flatMapIterable(o p0,c p1){
       a.c(p0, "mapper is null");
       a.c(p1, "resultSelector is null");
       return this.flatMap(t0.a(p0), p1, false, t.bufferSize(), t.bufferSize());
    }
    public final t flatMapMaybe(o p0){
       return this.flatMapMaybe(p0, false);
    }
    public final t flatMapMaybe(o p0,boolean p1){
       a.c(p0, "mapper is null");
       return a.h(new ObservableFlatMapMaybe(this, p0, p1));
    }
    public final t flatMapSingle(o p0){
       return this.flatMapSingle(p0, false);
    }
    public final t flatMapSingle(o p0,boolean p1){
       a.c(p0, "mapper is null");
       return a.h(new ObservableFlatMapSingle(this, p0, p1));
    }
    public final b forEach(g p0){
       return this.subscribe(p0);
    }
    public final b forEachWhile(r p0){
       return this.forEachWhile(p0, Functions.f, Functions.c);
    }
    public final b forEachWhile(r p0,g p1){
       return this.forEachWhile(p0, p1, Functions.c);
    }
    public final b forEachWhile(r p0,g p1,a p2){
       a.c(p0, "onNext is null");
       a.c(p1, "onError is null");
       a.c(p2, "onComplete is null");
       ForEachWhileObserver uForEachWhil = new ForEachWhileObserver(p0, p1, p2);
       this.subscribe(uForEachWhil);
       return uForEachWhil;
    }
    public final t groupBy(o p0){
       return this.groupBy(p0, Functions.e(), false, t.bufferSize());
    }
    public final t groupBy(o p0,o p1){
       return this.groupBy(p0, p1, false, t.bufferSize());
    }
    public final t groupBy(o p0,o p1,boolean p2){
       return this.groupBy(p0, p1, p2, t.bufferSize());
    }
    public final t groupBy(o p0,o p1,boolean p2,int p3){
       a.c(p0, "keySelector is null");
       a.c(p1, "valueSelector is null");
       a.d(p3, "bufferSize");
       ObservableGroupBy observableGr = new ObservableGroupBy(this, p0, p1, p3, p2);
       return a.h(v0);
    }
    public final t groupBy(o p0,boolean p1){
       return this.groupBy(p0, Functions.e(), p1, t.bufferSize());
    }
    public final t groupJoin(w p0,o p1,o p2,c p3){
       a.c(p0, "other is null");
       a.c(p1, "leftEnd is null");
       a.c(p2, "rightEnd is null");
       a.c(p3, "resultSelector is null");
       ObservableGroupJoin observableGr = new ObservableGroupJoin(this, p0, p1, p2, p3);
       return a.h(v0);
    }
    public final t hide(){
       return a.h(new q0(this));
    }
    public final a ignoreElements(){
       return a.e(new s0(this));
    }
    public final a0 isEmpty(){
       return this.all(Functions.i);
    }
    public final t join(w p0,o p1,o p2,c p3){
       a.c(p0, "other is null");
       a.c(p1, "leftEnd is null");
       a.c(p2, "rightEnd is null");
       a.c(p3, "resultSelector is null");
       ObservableJoin observableJo = new ObservableJoin(this, p0, p1, p2, p3);
       return a.h(v0);
    }
    public final a0 last(Object p0){
       a.c(p0, "defaultItem is null");
       return a.i(new w0(this, p0));
    }
    public final m lastElement(){
       return a.g(new v0(this));
    }
    public final a0 lastOrError(){
       return a.i(new w0(this, null));
    }
    public final t lift(h p0){
       a.c(p0, "onLift is null");
       return a.h(new x0(this, p0));
    }
    public final t map(o p0){
       a.c(p0, "mapper is null");
       return a.h(new y0(this, p0));
    }
    public final t materialize(){
       return a.h(new a1(this));
    }
    public final t mergeWith(e0 p0){
       a.c(p0, "other is null");
       return a.h(new ObservableMergeWithSingle(this, p0));
    }
    public final t mergeWith(e p0){
       a.c(p0, "other is null");
       return a.h(new ObservableMergeWithCompletable(this, p0));
    }
    public final t mergeWith(q p0){
       a.c(p0, "other is null");
       return a.h(new ObservableMergeWithMaybe(this, p0));
    }
    public final t mergeWith(w p0){
       a.c(p0, "other is null");
       return t.merge(this, p0);
    }
    public final t observeOn(z p0){
       return this.observeOn(p0, false, t.bufferSize());
    }
    public final t observeOn(z p0,boolean p1){
       return this.observeOn(p0, p1, t.bufferSize());
    }
    public final t observeOn(z p0,boolean p1,int p2){
       a.c(p0, "scheduler is null");
       a.d(p2, "bufferSize");
       return a.h(new ObservableObserveOn(this, p0, p1, p2));
    }
    public final t ofType(Class p0){
       a.c(p0, "clazz is null");
       return this.filter(new Functions$m(p0)).cast(p0);
    }
    public final t onErrorResumeNext(w p0){
       a.c(p0, "next is null");
       return this.onErrorResumeNext(Functions.g(p0));
    }
    public final t onErrorResumeNext(o p0){
       a.c(p0, "resumeFunction is null");
       return a.h(new c1(this, p0, false));
    }
    public final t onErrorReturn(o p0){
       a.c(p0, "valueSupplier is null");
       return a.h(new d1(this, p0));
    }
    public final t onErrorReturnItem(Object p0){
       a.c(p0, "item is null");
       return this.onErrorReturn(Functions.g(p0));
    }
    public final t onExceptionResumeNext(w p0){
       a.c(p0, "next is null");
       return a.h(new c1(this, Functions.g(p0), true));
    }
    public final t onTerminateDetach(){
       return a.h(new w(this));
    }
    public final t publish(o p0){
       a.c(p0, "selector is null");
       return a.h(new ObservablePublishSelector(this, p0));
    }
    public final a publish(){
       AtomicReference uAtomicRefer = new AtomicReference();
       return a.j(new ObservablePublish(new ObservablePublish$b(uAtomicRefer), this, uAtomicRefer));
    }
    public final a0 reduce(Object p0,c p1){
       a.c(p0, "seed is null");
       a.c(p1, "reducer is null");
       return a.i(new f1(this, p0, p1));
    }
    public final m reduce(c p0){
       a.c(p0, "reducer is null");
       return a.g(new e1(this, p0));
    }
    public final a0 reduceWith(Callable p0,c p1){
       a.c(p0, "seedSupplier is null");
       a.c(p1, "reducer is null");
       return a.i(new g1(this, p0, p1));
    }
    public final t repeat(){
       return this.repeat(Long.MAX_VALUE);
    }
    public final t repeat(long p0){
       if ((v2 = p0 - null) < 0) {
          throw new IllegalArgumentException("times >= 0 required but it was "+p0);
       }
       if (!v2) {
          return t.empty();
       }
       return a.h(new ObservableRepeat(this, p0));
    }
    public final t repeatUntil(e p0){
       a.c(p0, "stop is null");
       return a.h(new ObservableRepeatUntil(this, p0));
    }
    public final t repeatWhen(o p0){
       a.c(p0, "handler is null");
       return a.h(new ObservableRepeatWhen(this, p0));
    }
    public final t replay(o p0){
       a.c(p0, "selector is null");
       return ObservableReplay.h(t0.b(this), p0);
    }
    public final t replay(o p0,int p1){
       a.c(p0, "selector is null");
       a.d(p1, "bufferSize");
       return ObservableReplay.h(t0.c(this, p1), p0);
    }
    public final t replay(o p0,int p1,long p2,TimeUnit p3){
       return this.replay(p0, p1, p2, p3, b.a());
    }
    public final t replay(o p0,int p1,long p2,TimeUnit p3,z p4){
       a.c(p0, "selector is null");
       a.d(p1, "bufferSize");
       a.c(p3, "unit is null");
       a.c(p4, "scheduler is null");
       t0$b uob = new t0$b(this, p1, p2, p3, p4);
       return ObservableReplay.h(v0, p0);
    }
    public final t replay(o p0,int p1,z p2){
       a.c(p0, "selector is null");
       a.c(p2, "scheduler is null");
       a.d(p1, "bufferSize");
       return ObservableReplay.h(t0.c(this, p1), t0.d(p0, p2));
    }
    public final t replay(o p0,long p1,TimeUnit p2){
       return this.replay(p0, p1, p2, b.a());
    }
    public final t replay(o p0,long p1,TimeUnit p2,z p3){
       a.c(p0, "selector is null");
       a.c(p2, "unit is null");
       a.c(p3, "scheduler is null");
       t0$n on = new t0$n(this, p1, p2, p3);
       return ObservableReplay.h(v0, p0);
    }
    public final t replay(o p0,z p1){
       a.c(p0, "selector is null");
       a.c(p1, "scheduler is null");
       return ObservableReplay.h(t0.b(this), t0.d(p0, p1));
    }
    public final a replay(){
       return ObservableReplay.g(this);
    }
    public final a replay(int p0){
       a.d(p0, "bufferSize");
       a uoa = (p0 == Integer.MAX_VALUE)? ObservableReplay.g(this): ObservableReplay.f(this, new ObservableReplay$f(p0));
       return uoa;
    }
    public final a replay(int p0,long p1,TimeUnit p2){
       return this.replay(p0, p1, p2, b.a());
    }
    public final a replay(int p0,long p1,TimeUnit p2,z p3){
       a.d(p0, "bufferSize");
       a.c(p2, "unit is null");
       a.c(p3, "scheduler is null");
       return ObservableReplay.e(this, p1, p2, p3, p0);
    }
    public final a replay(int p0,z p1){
       a.d(p0, "bufferSize");
       return ObservableReplay.i(this.replay(p0), p1);
    }
    public final a replay(long p0,TimeUnit p1){
       return this.replay(p0, p1, b.a());
    }
    public final a replay(long p0,TimeUnit p1,z p2){
       a.c(p1, "unit is null");
       a.c(p2, "scheduler is null");
       return ObservableReplay.e(this, p0, p1, p2, Integer.MAX_VALUE);
    }
    public final a replay(z p0){
       a.c(p0, "scheduler is null");
       return ObservableReplay.i(this.replay(), p0);
    }
    public final t retry(){
       return this.retry(Long.MAX_VALUE, Functions.a());
    }
    public final t retry(long p0){
       return this.retry(p0, Functions.a());
    }
    public final t retry(long p0,r p1){
       if (p0 - null < 0) {
          throw new IllegalArgumentException("times >= 0 required but it was "+p0);
       }
       a.c(p1, "predicate is null");
       return a.h(new ObservableRetryPredicate(this, p0, p1));
    }
    public final t retry(d p0){
       a.c(p0, "predicate is null");
       return a.h(new ObservableRetryBiPredicate(this, p0));
    }
    public final t retry(r p0){
       return this.retry(Long.MAX_VALUE, p0);
    }
    public final t retryUntil(e p0){
       a.c(p0, "stop is null");
       return this.retry(Long.MAX_VALUE, new Functions$k(p0));
    }
    public final t retryWhen(o p0){
       a.c(p0, "handler is null");
       return a.h(new ObservableRetryWhen(this, p0));
    }
    public final void safeSubscribe(y p0){
       a.c(p0, "s is null");
       if (p0 instanceof f) {
          this.subscribe(p0);
       }else {
          this.subscribe(new f(p0));
       }
       return;
    }
    public final t sample(long p0,TimeUnit p1){
       return this.sample(p0, p1, b.a());
    }
    public final t sample(long p0,TimeUnit p1,z p2){
       a.c(p1, "unit is null");
       a.c(p2, "scheduler is null");
       ObservableSampleTimed observableSa = new ObservableSampleTimed(this, p0, p1, p2, false);
       return a.h(v0);
    }
    public final t sample(long p0,TimeUnit p1,z p2,boolean p3){
       a.c(p1, "unit is null");
       a.c(p2, "scheduler is null");
       ObservableSampleTimed observableSa = new ObservableSampleTimed(this, p0, p1, p2, p3);
       return a.h(v0);
    }
    public final t sample(long p0,TimeUnit p1,boolean p2){
       return this.sample(p0, p1, b.a(), p2);
    }
    public final t sample(w p0){
       a.c(p0, "sampler is null");
       return a.h(new ObservableSampleWithObservable(this, p0, false));
    }
    public final t sample(w p0,boolean p1){
       a.c(p0, "sampler is null");
       return a.h(new ObservableSampleWithObservable(this, p0, p1));
    }
    public final t scan(c p0){
       a.c(p0, "accumulator is null");
       return a.h(new h1(this, p0));
    }
    public final t scan(Object p0,c p1){
       a.c(p0, "seed is null");
       return this.scanWith(Functions.f(p0), p1);
    }
    public final t scanWith(Callable p0,c p1){
       a.c(p0, "seedSupplier is null");
       a.c(p1, "accumulator is null");
       return a.h(new i1(this, p0, p1));
    }
    public final t serialize(){
       return a.h(new j1(this));
    }
    public final t share(){
       return this.publish().d();
    }
    public final a0 single(Object p0){
       a.c(p0, "defaultItem is null");
       return a.i(new l1(this, p0));
    }
    public final m singleElement(){
       return a.g(new k1(this));
    }
    public final a0 singleOrError(){
       return a.i(new l1(this, null));
    }
    public final t skip(long p0){
       if (p0 - null <= 0) {
          return a.h(this);
       }
       return a.h(new m1(this, p0));
    }
    public final t skip(long p0,TimeUnit p1){
       return this.skipUntil(t.timer(p0, p1));
    }
    public final t skip(long p0,TimeUnit p1,z p2){
       return this.skipUntil(t.timer(p0, p1, p2));
    }
    public final t skipLast(int p0){
       if (p0 < 0) {
          throw new IndexOutOfBoundsException("count >= 0 required but it was "+p0);
       }
       if (!p0) {
          return a.h(this);
       }
       return a.h(new ObservableSkipLast(this, p0));
    }
    public final t skipLast(long p0,TimeUnit p1){
       return this.skipLast(p0, p1, b.f(), false, t.bufferSize());
    }
    public final t skipLast(long p0,TimeUnit p1,z p2){
       return this.skipLast(p0, p1, p2, false, t.bufferSize());
    }
    public final t skipLast(long p0,TimeUnit p1,z p2,boolean p3){
       return this.skipLast(p0, p1, p2, p3, t.bufferSize());
    }
    public final t skipLast(long p0,TimeUnit p1,z p2,boolean p3,int p4){
       a.c(p1, "unit is null");
       a.c(p2, "scheduler is null");
       a.d(p4, "bufferSize");
       ObservableSkipLastTimed observableSk = new ObservableSkipLastTimed(this, p0, p1, p2, (p4 << 1), p3);
       return a.h(p4);
    }
    public final t skipLast(long p0,TimeUnit p1,boolean p2){
       return this.skipLast(p0, p1, b.f(), p2, t.bufferSize());
    }
    public final t skipUntil(w p0){
       a.c(p0, "other is null");
       return a.h(new n1(this, p0));
    }
    public final t skipWhile(r p0){
       a.c(p0, "predicate is null");
       return a.h(new o1(this, p0));
    }
    public final t sorted(){
       return this.toList().d0().map(Functions.h(Functions$NaturalComparator.INSTANCE)).flatMapIterable(Functions.e());
    }
    public final t sorted(Comparator p0){
       a.c(p0, "sortFunction is null");
       return this.toList().d0().map(Functions.h(p0)).flatMapIterable(Functions.e());
    }
    public final t startWith(w p0){
       a.c(p0, "other is null");
       w[] owArray = new w[]{p0,this};
       return t.concatArray(owArray);
    }
    public final t startWith(Iterable p0){
       w[] owArray = new w[]{t.fromIterable(p0),this};
       return t.concatArray(owArray);
    }
    public final t startWith(Object p0){
       a.c(p0, "item is null");
       w[] owArray = new w[]{t.just(p0),this};
       return t.concatArray(owArray);
    }
    public final t startWithArray(Object[] p0){
       t ot = t.fromArray(p0);
       if (ot == t.empty()) {
          return a.h(this);
       }
       w[] owArray = new w[]{ot,this};
       return t.concatArray(owArray);
    }
    public final b subscribe(){
       return this.subscribe(Functions.d(), Functions.f, Functions.c, Functions.d());
    }
    public final b subscribe(g p0){
       return this.subscribe(p0, Functions.f, Functions.c, Functions.d());
    }
    public final b subscribe(g p0,g p1){
       return this.subscribe(p0, p1, Functions.c, Functions.d());
    }
    public final b subscribe(g p0,g p1,a p2){
       return this.subscribe(p0, p1, p2, Functions.d());
    }
    public final b subscribe(g p0,g p1,a p2,g p3){
       a.c(p0, "onNext is null");
       a.c(p1, "onError is null");
       a.c(p2, "onComplete is null");
       a.c(p3, "onSubscribe is null");
       LambdaObserver lambdaObserv = new LambdaObserver(p0, p1, p2, p3);
       this.subscribe(lambdaObserv);
       return lambdaObserv;
    }
    public final void subscribe(y p0){
       String str = "observer is null";
       try{
          a.c(p0, str);
          c u = a.u;
          if (u != null) {
             p0 = a.a(u, this, p0);
          }
          a.c(p0, "Plugin returned null Observer");
          this.subscribeActual(p0);
          return;
       }catch(java.lang.NullPointerException e3){
          throw e3;
       }
    }
    public abstract void subscribeActual(y p0);
    public final t subscribeOn(z p0){
       a.c(p0, "scheduler is null");
       return a.h(new ObservableSubscribeOn(this, p0));
    }
    public final y subscribeWith(y p0){
       this.subscribe(p0);
       return p0;
    }
    public final t switchIfEmpty(w p0){
       a.c(p0, "other is null");
       return a.h(new p1(this, p0));
    }
    public final t switchMap(o p0){
       return this.switchMap(p0, t.bufferSize());
    }
    public final t switchMap(o p0,int p1){
       a.c(p0, "mapper is null");
       a.d(p1, "bufferSize");
       if (!this instanceof m) {
          return a.h(new ObservableSwitchMap(this, p0, p1, false));
       }
       Object obj = this.call();
       if (obj == null) {
          return t.empty();
       }
       return ObservableScalarXMap.a(obj, p0);
    }
    public final a switchMapCompletable(o p0){
       a.c(p0, "mapper is null");
       return a.e(new ObservableSwitchMapCompletable(this, p0, false));
    }
    public final a switchMapCompletableDelayError(o p0){
       a.c(p0, "mapper is null");
       return a.e(new ObservableSwitchMapCompletable(this, p0, true));
    }
    public final t switchMapDelayError(o p0){
       return this.switchMapDelayError(p0, t.bufferSize());
    }
    public final t switchMapDelayError(o p0,int p1){
       a.c(p0, "mapper is null");
       a.d(p1, "bufferSize");
       if (!this instanceof m) {
          return a.h(new ObservableSwitchMap(this, p0, p1, true));
       }
       Object obj = this.call();
       if (obj == null) {
          return t.empty();
       }
       return ObservableScalarXMap.a(obj, p0);
    }
    public final t switchMapMaybe(o p0){
       a.c(p0, "mapper is null");
       return a.h(new ObservableSwitchMapMaybe(this, p0, false));
    }
    public final t switchMapMaybeDelayError(o p0){
       a.c(p0, "mapper is null");
       return a.h(new ObservableSwitchMapMaybe(this, p0, true));
    }
    public final t switchMapSingle(o p0){
       a.c(p0, "mapper is null");
       return a.h(new ObservableSwitchMapSingle(this, p0, false));
    }
    public final t switchMapSingleDelayError(o p0){
       a.c(p0, "mapper is null");
       return a.h(new ObservableSwitchMapSingle(this, p0, true));
    }
    public final t take(long p0){
       if (p0 - null >= 0) {
          return a.h(new q1(this, p0));
       }
       throw new IllegalArgumentException("count >= 0 required but it was "+p0);
    }
    public final t take(long p0,TimeUnit p1){
       return this.takeUntil(t.timer(p0, p1));
    }
    public final t take(long p0,TimeUnit p1,z p2){
       return this.takeUntil(t.timer(p0, p1, p2));
    }
    public final t takeLast(int p0){
       if (p0 < 0) {
          throw new IndexOutOfBoundsException("count >= 0 required but it was "+p0);
       }
       if (!p0) {
          return a.h(new r0(this));
       }
       if (p0 == 1) {
          return a.h(new r1(this));
       }
       return a.h(new ObservableTakeLast(this, p0));
    }
    public final t takeLast(long p0,long p1,TimeUnit p2){
       return this.takeLast(p0, p1, p2, b.f(), false, t.bufferSize());
    }
    public final t takeLast(long p0,long p1,TimeUnit p2,z p3){
       return this.takeLast(p0, p1, p2, p3, false, t.bufferSize());
    }
    public final t takeLast(long p0,long p1,TimeUnit p2,z p3,boolean p4,int p5){
       a.c(p2, "unit is null");
       a.c(p3, "scheduler is null");
       a.d(p5, "bufferSize");
       if (p0 - null < 0) {
          throw new IndexOutOfBoundsException("count >= 0 required but it was "+p0);
       }
       ObservableTakeLastTimed observableTa = new ObservableTakeLastTimed(this, p0, p1, p2, p3, p5, p4);
       return a.h(v10);
    }
    public final t takeLast(long p0,TimeUnit p1){
       return this.takeLast(p0, p1, b.f(), false, t.bufferSize());
    }
    public final t takeLast(long p0,TimeUnit p1,z p2){
       return this.takeLast(p0, p1, p2, false, t.bufferSize());
    }
    public final t takeLast(long p0,TimeUnit p1,z p2,boolean p3){
       return this.takeLast(p0, p1, p2, p3, t.bufferSize());
    }
    public final t takeLast(long p0,TimeUnit p1,z p2,boolean p3,int p4){
       return this.takeLast(Long.MAX_VALUE, p0, p1, p2, p3, p4);
    }
    public final t takeLast(long p0,TimeUnit p1,boolean p2){
       return this.takeLast(p0, p1, b.f(), p2, t.bufferSize());
    }
    public final t takeUntil(w p0){
       a.c(p0, "other is null");
       return a.h(new ObservableTakeUntil(this, p0));
    }
    public final t takeUntil(r p0){
       a.c(p0, "predicate is null");
       return a.h(new s1(this, p0));
    }
    public final t takeWhile(r p0){
       a.c(p0, "predicate is null");
       return a.h(new t1(this, p0));
    }
    public final TestObserver test(){
       TestObserver testObserver = new TestObserver();
       this.subscribe(testObserver);
       return testObserver;
    }
    public final TestObserver test(boolean p0){
       TestObserver testObserver = new TestObserver();
       if (p0) {
          testObserver.dispose();
       }
       this.subscribe(testObserver);
       return testObserver;
    }
    public final t throttleFirst(long p0,TimeUnit p1){
       return this.throttleFirst(p0, p1, b.a());
    }
    public final t throttleFirst(long p0,TimeUnit p1,z p2){
       a.c(p1, "unit is null");
       a.c(p2, "scheduler is null");
       ObservableThrottleFirstTimed observableTh = new ObservableThrottleFirstTimed(this, p0, p1, p2);
       return a.h(v0);
    }
    public final t throttleLast(long p0,TimeUnit p1){
       return this.sample(p0, p1);
    }
    public final t throttleLast(long p0,TimeUnit p1,z p2){
       return this.sample(p0, p1, p2);
    }
    public final t throttleLatest(long p0,TimeUnit p1){
       return this.throttleLatest(p0, p1, b.a(), false);
    }
    public final t throttleLatest(long p0,TimeUnit p1,z p2){
       return this.throttleLatest(p0, p1, p2, false);
    }
    public final t throttleLatest(long p0,TimeUnit p1,z p2,boolean p3){
       a.c(p1, "unit is null");
       a.c(p2, "scheduler is null");
       ObservableThrottleLatest observableTh = new ObservableThrottleLatest(this, p0, p1, p2, p3);
       return a.h(v0);
    }
    public final t throttleLatest(long p0,TimeUnit p1,boolean p2){
       return this.throttleLatest(p0, p1, b.a(), p2);
    }
    public final t throttleWithTimeout(long p0,TimeUnit p1){
       return this.debounce(p0, p1);
    }
    public final t throttleWithTimeout(long p0,TimeUnit p1,z p2){
       return this.debounce(p0, p1, p2);
    }
    public final t timeInterval(){
       return this.timeInterval(TimeUnit.MILLISECONDS, b.a());
    }
    public final t timeInterval(z p0){
       return this.timeInterval(TimeUnit.MILLISECONDS, p0);
    }
    public final t timeInterval(TimeUnit p0){
       return this.timeInterval(p0, b.a());
    }
    public final t timeInterval(TimeUnit p0,z p1){
       a.c(p0, "unit is null");
       a.c(p1, "scheduler is null");
       return a.h(new u1(this, p0, p1));
    }
    public final t timeout(long p0,TimeUnit p1){
       return this.timeout0(p0, p1, null, b.a());
    }
    public final t timeout(long p0,TimeUnit p1,w p2){
       a.c(p2, "other is null");
       return this.timeout0(p0, p1, p2, b.a());
    }
    public final t timeout(long p0,TimeUnit p1,z p2){
       return this.timeout0(p0, p1, null, p2);
    }
    public final t timeout(long p0,TimeUnit p1,z p2,w p3){
       a.c(p3, "other is null");
       return this.timeout0(p0, p1, p3, p2);
    }
    public final t timeout(w p0,o p1){
       a.c(p0, "firstTimeoutIndicator is null");
       return this.timeout0(p0, p1, null);
    }
    public final t timeout(w p0,o p1,w p2){
       a.c(p0, "firstTimeoutIndicator is null");
       a.c(p2, "other is null");
       return this.timeout0(p0, p1, p2);
    }
    public final t timeout(o p0){
       return this.timeout0(null, p0, null);
    }
    public final t timeout(o p0,w p1){
       a.c(p1, "other is null");
       return this.timeout0(null, p0, p1);
    }
    public final t timeout0(long p0,TimeUnit p1,w p2,z p3){
       a.c(p1, "timeUnit is null");
       a.c(p3, "scheduler is null");
       ObservableTimeoutTimed observableTi = new ObservableTimeoutTimed(this, p0, p1, p3, p2);
       return a.h(v0);
    }
    public final t timeout0(w p0,o p1,w p2){
       a.c(p1, "itemTimeoutIndicator is null");
       return a.h(new ObservableTimeout(this, p0, p1, p2));
    }
    public final t timestamp(){
       return this.timestamp(TimeUnit.MILLISECONDS, b.a());
    }
    public final t timestamp(z p0){
       return this.timestamp(TimeUnit.MILLISECONDS, p0);
    }
    public final t timestamp(TimeUnit p0){
       return this.timestamp(p0, b.a());
    }
    public final t timestamp(TimeUnit p0,z p1){
       a.c(p0, "unit is null");
       a.c(p1, "scheduler is null");
       return this.map(new Functions$f0(p0, p1));
    }
    public final Object to(o p0){
       a.c(p0, "converter is null");
       return p0.apply(this);
    }
    public final h toFlowable(BackpressureStrategy p0){
       k ok = new k(this);
       int i = t$a.a[p0.ordinal()];
       if (i == 1) {
          return ok.u();
       }
       if (i == 2) {
          return a.f(new FlowableOnBackpressureLatest(ok));
       }
       if (i == 3) {
          return ok;
       }
       if (i == 4) {
          return a.f(new FlowableOnBackpressureError(ok));
       }
       int i1 = h.b();
       a.d(i1, "bufferSize");
       FlowableOnBackpressureBuffer uFlowableOnB = new FlowableOnBackpressureBuffer(ok, i1, true, false, Functions.c);
       return a.f("bufferSize");
    }
    public final Future toFuture(){
       return this.subscribeWith(new h());
    }
    public final a0 toList(){
       return this.toList(16);
    }
    public final a0 toList(int p0){
       a.d(p0, "capacityHint");
       return a.i(new w1(this, p0));
    }
    public final a0 toList(Callable p0){
       a.c(p0, "collectionSupplier is null");
       return a.i(new w1(this, p0));
    }
    public final a0 toMap(o p0){
       a.c(p0, "keySelector is null");
       return this.collect(HashMapSupplier.asCallable(), new Functions$g0(p0));
    }
    public final a0 toMap(o p0,o p1){
       a.c(p0, "keySelector is null");
       a.c(p1, "valueSelector is null");
       return this.collect(HashMapSupplier.asCallable(), Functions.r(p0, p1));
    }
    public final a0 toMap(o p0,o p1,Callable p2){
       a.c(p0, "keySelector is null");
       a.c(p1, "valueSelector is null");
       a.c(p2, "mapSupplier is null");
       return this.collect(p2, Functions.r(p0, p1));
    }
    public final a0 toMultimap(o p0){
       return this.toMultimap(p0, Functions.e(), HashMapSupplier.asCallable(), ArrayListSupplier.asFunction());
    }
    public final a0 toMultimap(o p0,o p1){
       return this.toMultimap(p0, p1, HashMapSupplier.asCallable(), ArrayListSupplier.asFunction());
    }
    public final a0 toMultimap(o p0,o p1,Callable p2){
       return this.toMultimap(p0, p1, p2, ArrayListSupplier.asFunction());
    }
    public final a0 toMultimap(o p0,o p1,Callable p2,o p3){
       a.c(p0, "keySelector is null");
       a.c(p1, "valueSelector is null");
       a.c(p2, "mapSupplier is null");
       a.c(p3, "collectionFactory is null");
       return this.collect(p2, new Functions$i0(p3, p1, p0));
    }
    public final a0 toSortedList(){
       return this.toSortedList(Functions.i());
    }
    public final a0 toSortedList(int p0){
       return this.toSortedList(Functions.i(), p0);
    }
    public final a0 toSortedList(Comparator p0){
       a.c(p0, "comparator is null");
       return this.toList().C(Functions.h(p0));
    }
    public final a0 toSortedList(Comparator p0,int p1){
       a.c(p0, "comparator is null");
       return this.toList(p1).C(Functions.h(p0));
    }
    public final t unsubscribeOn(z p0){
       a.c(p0, "scheduler is null");
       return a.h(new ObservableUnsubscribeOn(this, p0));
    }
    public final t window(long p0){
       return this.window(p0, p0, t.bufferSize());
    }
    public final t window(long p0,long p1){
       return this.window(p0, p1, t.bufferSize());
    }
    public final t window(long p0,long p1,int p2){
       a.e(p0, "count");
       a.e(p1, "skip");
       a.d(p2, "bufferSize");
       ObservableWindow observableWi = new ObservableWindow(this, p0, p1, p2);
       return a.h(v0);
    }
    public final t window(long p0,long p1,TimeUnit p2){
       return this.window(p0, p1, p2, b.a(), t.bufferSize());
    }
    public final t window(long p0,long p1,TimeUnit p2,z p3){
       return this.window(p0, p1, p2, p3, t.bufferSize());
    }
    public final t window(long p0,long p1,TimeUnit p2,z p3,int p4){
       a.e(p0, "timespan");
       long l = p1;
       a.e(l, "timeskip");
       int i = p4;
       a.d(i, "bufferSize");
       Object obj = p3;
       a.c(obj, "scheduler is null");
       Object obj1 = p2;
       a.c(obj1, "unit is null");
       y1 oy1 = new y1(this, p0, l, obj1, obj, Long.MAX_VALUE, i, false);
       return a.h(v0);
    }
    public final t window(long p0,TimeUnit p1){
       return this.window(p0, p1, b.a(), Long.MAX_VALUE, false);
    }
    public final t window(long p0,TimeUnit p1,long p2){
       return this.window(p0, p1, b.a(), p2, false);
    }
    public final t window(long p0,TimeUnit p1,long p2,boolean p3){
       return this.window(p0, p1, b.a(), p2, p3);
    }
    public final t window(long p0,TimeUnit p1,z p2){
       return this.window(p0, p1, p2, Long.MAX_VALUE, false);
    }
    public final t window(long p0,TimeUnit p1,z p2,long p3){
       return this.window(p0, p1, p2, p3, false);
    }
    public final t window(long p0,TimeUnit p1,z p2,long p3,boolean p4){
       return this.window(p0, p1, p2, p3, p4, t.bufferSize());
    }
    public final t window(long p0,TimeUnit p1,z p2,long p3,boolean p4,int p5){
       int i = p5;
       a.d(i, "bufferSize");
       Object obj = p2;
       a.c(obj, "scheduler is null");
       Object obj1 = p1;
       a.c(obj1, "unit is null");
       long l = p3;
       a.e(l, "count");
       y1 oy1 = new y1(this, p0, p0, obj1, obj, l, i, p4);
       return a.h(v0);
    }
    public final t window(w p0){
       return this.window(p0, t.bufferSize());
    }
    public final t window(w p0,int p1){
       a.c(p0, "boundary is null");
       a.d(p1, "bufferSize");
       return a.h(new ObservableWindowBoundary(this, p0, p1));
    }
    public final t window(w p0,o p1){
       return this.window(p0, p1, t.bufferSize());
    }
    public final t window(w p0,o p1,int p2){
       a.c(p0, "openingIndicator is null");
       a.c(p1, "closingIndicator is null");
       a.d(p2, "bufferSize");
       return a.h(new x1(this, p0, p1, p2));
    }
    public final t window(Callable p0){
       return this.window(p0, t.bufferSize());
    }
    public final t window(Callable p0,int p1){
       a.c(p0, "boundary is null");
       a.d(p1, "bufferSize");
       return a.h(new ObservableWindowBoundarySupplier(this, p0, p1));
    }
    public final t withLatestFrom(w p0,w p1,w p2,w p3,j p4){
       a.c(p0, "o1 is null");
       a.c(p1, "o2 is null");
       a.c(p2, "o3 is null");
       a.c(p3, "o4 is null");
       a.c(p4, "combiner is null");
       w[] owArray = new w[]{p0,p1,p2,p3};
       return this.withLatestFrom(owArray, Functions.m(p4));
    }
    public final t withLatestFrom(w p0,w p1,w p2,i p3){
       a.c(p0, "o1 is null");
       a.c(p1, "o2 is null");
       a.c(p2, "o3 is null");
       a.c(p3, "combiner is null");
       w[] owArray = new w[]{p0,p1,p2};
       return this.withLatestFrom(owArray, Functions.l(p3));
    }
    public final t withLatestFrom(w p0,w p1,h p2){
       a.c(p0, "o1 is null");
       a.c(p1, "o2 is null");
       a.c(p2, "combiner is null");
       w[] owArray = new w[]{p0,p1};
       return this.withLatestFrom(owArray, Functions.k(p2));
    }
    public final t withLatestFrom(w p0,c p1){
       a.c(p0, "other is null");
       a.c(p1, "combiner is null");
       return a.h(new ObservableWithLatestFrom(this, p1, p0));
    }
    public final t withLatestFrom(Iterable p0,o p1){
       a.c(p0, "others is null");
       a.c(p1, "combiner is null");
       return a.h(new ObservableWithLatestFromMany(this, p0, p1));
    }
    public final t withLatestFrom(w[] p0,o p1){
       a.c(p0, "others is null");
       a.c(p1, "combiner is null");
       return a.h(new ObservableWithLatestFromMany(this, p0, p1));
    }
    public final t zipWith(w p0,c p1){
       a.c(p0, "other is null");
       return t.zip(this, p0, p1);
    }
    public final t zipWith(w p0,c p1,boolean p2){
       return t.zip(this, p0, p1, p2);
    }
    public final t zipWith(w p0,c p1,boolean p2,int p3){
       return t.zip(this, p0, p1, p2, p3);
    }
    public final t zipWith(Iterable p0,c p1){
       a.c(p0, "other is null");
       a.c(p1, "zipper is null");
       return a.h(new z1(this, p0, p1));
    }
}
